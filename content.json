{"posts":[{"title":"2022巅峰极客Crypto wp","text":"做了一下巅峰极客的Crypto，emm很可惜差点AK（crypto3赛后不久出的）。题目不多，质量一般，有脑残题，也有没遇到过的攻击手法。就当练练手了，稍微记录一下吧。 point-power 题目源码： 123456789101112131415161718192021from Crypto.Util.number import *from gmpy2 import *from random import *from secrets import flagassert len(flag)==42p=getPrime(600)a=bytes_to_long(flag)b=randrange(2,p-1)E=EllipticCurve(GF(p),[a,b])G=E.random_element()x1,y1,_=GG=2*Gx2,y2,_=Gprint(f\"p = {p}\")print(f\"b = {b}\")print(f\"x1 = {x1}\")print(f\"x2 = {x2}\") 定义了一条椭圆曲线，已知曲线参数b和p，告诉了曲线上随机点G及2G的x坐标，求曲线参数a的值。 那么我们很自然地联想到G和2G之间x坐标的关系式： 然后由于有： 消去可以得到： 解关于a的方程即可 解题脚本solve.sage: 12345678910111213from Crypto.Util.number import *p = 3660057339895840489386133099442699911046732928957592389841707990239494988668972633881890332850396642253648817739844121432749159024098337289268574006090698602263783482687565322890623b = 1515231655397326550194746635613443276271228200149130229724363232017068662367771757907474495021697632810542820366098372870766155947779533427141016826904160784021630942035315049381147x1 = 2157670468952062330453195482606118809236127827872293893648601570707609637499023981195730090033076249237356704253400517059411180554022652893726903447990650895219926989469443306189740x2 = 1991876990606943816638852425122739062927245775025232944491452039354255349384430261036766896859410449488871048192397922549895939187691682643754284061389348874990018070631239671589727R.&lt;a&gt;=PolynomialRing(Zmod(p))f=(3*x1^2+a)^2-4*(2*x1+x2)*(x1^3+a*x1+b)f=f.monic()res=f.roots()for a,_ in res: print(long_to_bytes(int(a))) strange curve 题目源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192from Crypto.Util.number import *from gmpy2 import *from secrets import flagimport randomdef add(P,Q): (x1,y1)=P (x2,y2)=Q x3=(x1+x2)*(1+y1*y2)*invert((1+x1*x2)*(1-y1*y2),p)%p y3=(y1+y2)*(1+x1*x2)*invert((1-x1*x2)*(1+y1*y2),p)%p return (x3,y3)def mul(e,P): Q=(0,0) e=e%p while e: if e&amp;1: Q=add(Q,P) P=add(P,P) e&gt;&gt;=1 return Qdef Legendre(a,p): return (pow((a%p+p)%p,(p-1)//2,p))%pdef get_ts(p): p=p-1 count=0 while p%2==0: count+=1 p=p//2 return count,pdef get_nonre(p): a=random.randint(1,p) while Legendre(a,p)==1: a=random.randint(1,p) return adef amm2(a,p): t,s=get_ts(p) ta=pow(get_nonre(p),s,p) tb=pow(a,s,p) h=1 for i in range(1,t): d=pow(tb,2**t-1-i,p) if d==1: k=0 else: k=1 tb=(tb*pow(ta,2*k,p))%p h=(h*pow(ta,k,p))%p ta=pow(ta,2,p) return h*pow(a,(s+1)//2,p)%p def solve(a,b,c,p): tmpa=1 tmpb=b*inverse(a,p)%p tmpc=c*inverse(a,p)%p assert Legendre(tmpb**2*inverse(4,p)-tmpc,p)==1 res1=(amm2(tmpb**2*inverse(4,p)-tmpc,p)-tmpb*inverse(2,p))%p res2=(-amm2(tmpb**2*inverse(4,p)-tmpc,p)-tmpb*inverse(2,p))%p return (res1,res2)def lift(x,a,b,p): tmp=b*(x**2-1)*inverse(a*x,p)%p return solve(1,-tmp,-1,p)[0]p=9410547699903726871336507117271550134683191140146415131394654141737636910570480327296351841515571767317596027931492843621727002889086193529096531342265353a=54733430689690725746438325219044741824500093621550218736194675295708808435509b=75237024593957256761258687646797952793573177095902495908321724558796076392871x=bytes_to_long(flag)while True: try: y=lift(x,a,b,p) break except: x+=1 continueassert a*x*(y**2-1)%p==b*y*(x**2-1)%pP=(x,y)e=65537eP=mul(e,P)print(f\"P = {P}\")print(f\"eP = {eP}\") 脑残题目，要求的P点x坐标直接给出来了，long_to_bytes就完事了。不明白出题人的真实想法，或许是想从eP推回P？ Learning with fault 题目源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from Crypto.Util.number import *from gmpy2 import *from secrets import flagimport osclass RSA(): def __init__(self,p,q,e): self.p=p self.q=q self.e=e self.phi=(p-1)*(q-1) self.d=invert(self.e,self.phi) self.dp=self.d%(p-1) self.dq=self.d%(q-1) self.n=p*q self.N=getPrime(512)*getPrime(512) def sign(self,message): m=bytes_to_long(message) sig_p=pow(m,self.dp,self.p) sig_q=pow(m,self.dq,self.q) alpha=q*invert(q,p) beta=p*invert(p,q) return long_to_bytes((alpha*sig_p+beta*sig_q)%self.n) def corrupt_sign(self,message): m=bytes_to_long(message) sig_p=pow(m,self.dp,self.p) sig_q=pow(m,self.dq,self.q) alpha=q*invert(q,p) beta=p*invert(p,q) return long_to_bytes((alpha*sig_p+beta*sig_q)%self.N) def verify(self,message,sign): return long_to_bytes(pow(bytes_to_long(sign),self.e,self.n))==messagep=getPrime(512)q=getPrime(512)e=65537rsa=RSA(p,q,e)with open(\"sign.txt\",\"w\") as f1: with open(\"corrupted_sign.txt\",\"w\") as f2: for _ in range(6): message=os.urandom(64) sign=rsa.sign(message) corrupted_sign=rsa.corrupt_sign(message) assert rsa.verify(message,sign) f1.write(str(sign)+'\\n') f2.write(str(corrupted_sign)+'\\n')enc=pow(bytes_to_long(flag),rsa.e,rsa.n)print(f\"n = {rsa.n}\")print(f\"N = {rsa.N}\")print(f\"e = {rsa.e}\")print(f\"enc = {enc}\") RSA签名，不过签名方式不是直接pow(m,d,n)，而是另一种奇怪的方式。sign和corrupt_sign的区别仅在于最后的模数n不同。提供了6组随机消息的签名，需要分解n来解最后的RSA加密。看了一会儿无从下手，然后结合题目名搜了一会儿，发现是Modulus Fault Attacks Against RSA-CRT Signatures，直接有论文讲解了该攻击的原理和具体实施流程。大致思想是利用多维正交格得到规约基，从而构造与n相关的参数并gcd分解。目前细致原理还没仔细研究，只是先实现了出来，这里先码一下，以后有空再研究。 比赛时没写出来，还是写脚本太慢了。 解题脚本solve.sage: 123456789101112131415161718192021222324252627282930313233343536373839404142434445from Crypto.Util.number import *from gmpy2 import *from random import randrangesign_data=open('sign.txt','rb').read()corrupted_data=open('corrupted_sign.txt','rb').read()signs=[bytes_to_long(eval(s)) for s in sign_data.split(b'\\n')[:-1]]corrupted_signs=[bytes_to_long(eval(s)) for s in corrupted_data.split(b'\\n')[:-1]]n = 99670316685463632788041383175090257045961799409733877510733415402955763322569510896091638507050126669571444467488936880059210773298729542608112756526719533574432327269721804307073353651955251188547245641771980139488000798458617636759823027148955008149512692983471670488580994385743789385091027299901520585729N = 81332992898551792936282861980393365170738006789835182134055801566584228471896473385776004610279937176800796971820133195300006470892468060034368863410462219133248069442508287516929262751427926825122839525496671527936622212986733708071962237633082743396115729744192159064241674410003857168101669882043743570731e = 65537enc = 2476965183785968993595493003363618829317072815989584886372189393899395623714779397354978469504773556228655475355703015337932838278988328384587983506790841663233499939173166353582189202860394411808445422387063648198432242875738065748287034529713834303346017134249834382745931627301273142828893469374138264396l=6v=[ crt([s,cs],[n,N]) for s,cs in zip(signs,corrupted_signs)]k1=randrange(n)vk=k1*vector(v)m1=Matrix(ZZ,l,l+1)m1.set_column(0,vk)for i in range(l): m1[i,i+1]=1m11=m1.LLL()k2=randrange(n)m2=Matrix(ZZ,l,2*l-2)for i in range(l-2): m2.set_column(i,k2*m11.row(i)[1:])for i in range(l-2,2*l-2): m2[i-l+2,i]=1m22=m2.LLL()basis=[ m22.row(i)[-l:] for i in range(l)]for a in range(-10,10): for b in range(-10,10): z=a*basis[0]+b*basis[1] for vv,zz in zip(v,z): g=gcd(vv-zz,n) if g!=1: p=g q=n//p d=inverse(e,(p-1)*(q-1)) m=pow(enc,d,n) print(long_to_bytes(int(m))) exit(0)","link":"/202208/960e02cb.html"},{"title":"2022羊城杯Crypto wp","text":"比赛只有24h，记录一下做出来的几个题，后面太晚了实在干不动了。 EasyRsa 题目源码： 12345678910111213from flag import flagfrom Crypto.Util.number import *m = bytes_to_long(flag)e = 65537f = open(\"output.txt\", \"r\")a = f.readlines()for i in a: n = int(i) c = pow(m, e, n) m = cprint 'c = %s' % (m)f.close() output里面是一些n值，gcd一下可以发现全都有一个相同的公因子，那没啥好说的分解倒着解回来就完事儿了。 解题脚本： 12345678910111213141516171819from Crypto.Util.number import *c = 38127524839835864306737280818907796566475979451567460500065967565655632622992572530918601432256137666695102199970580936307755091109351218835095309766358063857260088937006810056236871014903809290530667071255731805071115169201705265663551734892827553733293929057918850738362888383312352624299108382366714432727e = 65537f = open(\"output.txt\", \"r\")ns = [ int(line) for line in f.readlines() if line.strip()]'''for i in range(len(ns)): for j in range(i+1,len(ns)): print(GCD(ns[i],ns[j]))#7552850543392291177573335134779451826968284497191536051874894984844023350777357739533061306212635723884437778881981836095720474943879388731913801454095897'''p=7552850543392291177573335134779451826968284497191536051874894984844023350777357739533061306212635723884437778881981836095720474943879388731913801454095897for n in ns[::-1]: q=n//p d=inverse(e,(p-1)*(q-1)) c=pow(c,d,n)print(long_to_bytes(c))#b'GWHT{gixkJl7SJTcpLOL9zqwo}' LRSA 题目源码： 1234567891011121314151617181920212223242526from Crypto.Util.number import *import gmpy2from flag import flagm=bytes_to_long(flag)def getPQ(p,q): P=getPrime(2048) Q=getPrime(2048) t=(p*P-58*P+q)%Q assert (isPrime(Q)) return P,Q,tB=getRandomNBitInteger(11)p=getPrime(B)q=getPrime(B)n=p*qe=65537c=pow(m,e,n)P,Q,t=getPQ(p,q)print(\"B=\",B)print(\"P*P*Q=\",P*P*Q)print(\"P*Q*Q=\",P*Q*Q)print(\"t=\",t)print(\"c=\",c) 首先可以根据提供的值求出和，然后我们观察到非常小，因此有： 又由于，因此有： 因此对进行连分数展开，即可找到某一逼近的分母为，从而求得值，接着带回原式可求得，然后解RSA即可。 解题脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from Crypto.Util.number import *from gmpy2 import irootB=1023PPQ=17550772391048142376662352375650397168226219900284185133945819378595084615279414529115194246625188015626268312188291451580718399491413731583962229337205180301248556893326419027312533686033888462669675100382278716791450615542537581657011200868911872550652311318486382920999726120813916439522474691195194557657267042628374572411645371485995174777885120394234154274071083542059010253657420242098856699109476857347677270860654429688935924519805555787949683144015873225388396740487817155358042797286990338440987035608851331840925854381286767024584195081004360635842976624747610461507795755042915965483135990495921912997789567020652729777216671481467049291624343256152446367091568361258918212012737611001009003078023715854575413979603297947011959023398306612437250872299406744778763429172689675430968886613391356192380152315042387148665654062576525633130546454743040442444227245763939134967515614637300940642555367668537324892890004459521919887178391559206373513466653484926149453481758790663522317898916616435463486824881406198956479504970446076256447830689197409184703931842169195650953917594642601134810084247402051464584676932882503143409428970896718980446185114397748313655630266379123438583315809104543663538494519415242569480492899140190587129956835218417371308642212037424611690324353109931657289337536406499314388951678319136343913551598851601805737870217800009086551022197432448461112330252097447894028786035069710260561955740514091976513928307284531381150606428802334767412638213776730300093872457594524254858721551285338651364457529927871215183857169772407595348187949014442596356406144157105062291018215254440382214000573515515859668018846789551567310531570458316720877172632139481792680258388798439064221051325274383331521717987420093245521230610073103811158660291643007279940393509663374960353315388446956868294358252276964954745551655711981PQQ=17632503734712698604217167790453868045296303200715867263641257955056721075502316035280716025016839471684329988600978978424661087892466132185482035374940487837109552684763339574491378951189521258328752145077889261805000262141719400516584216130899437363088936913664419705248701787497332582188063869114908628807937049986360525010012039863210179017248132893824655341728382780250878156526086594253092249935304259986328308203344932540888448163430113818706295806406535364433801544858874357459282988110371175948011077595778123265914357153104206808258347815853145593128831233094769191889153762451880396333921190835200889266000562699392602082643298040136498839726733129090381507278582253125509943696419087708429546384313035073010683709744463087794325058122495375333875728593383803489271258323466068830034394348582326189840226236821974979834541554188673335151333713605570214286605391522582123096490317734786072061052604324131559447145448500381240146742679889154145555389449773359530020107821711994953950072547113428811855524572017820861579995449831880269151834230607863568992929328355995768974532894288752369127771516710199600449849031992434777962666440682129817924824151147427747882725858977273856311911431085373396551436319200582072164015150896425482384248479071434032953021738952688256364397405939276917210952583838731888536160866721278250628482428975748118973182256529453045184370543766401320261730361611365906347736001225775255350554164449014831203472238042057456969218316231699556466298168668958678855382462970622819417830000343573014265235688391542452769592096406400900187933156352226983897249981036555748543606676736274049188713348408983072484516372145496924391146241282884948724825393087105077360952770212959517318021248639012476095670769959011548699960423508352158455979906789927951812368185987838359200354730654103428077770839008773864604836807261909t=44c=4364802217291010807437827526073499188746160856656033054696031258814848127341094853323797303333741617649819892633013549917144139975939225893749114460910089509552261297408649636515368831194227006310835137628421405558641056278574098849091436284763725120659865442243245486345692476515256604820175726649516152356765363753262839864657243662645981385763738120585801720865252694204286145009527172990713740098977714337038793323846801300955225503801654258983911473974238212956519721447805792992654110642511482243273775873164502478594971816554268730722314333969932527553109979814408613177186842539860073028659812891580301154746e=65537def simplify_fraction(e,n,max_size): assert e&lt;n simp_list=[] for i in range(max_size): if e==0: break t=n//e simp_list.append(t) (e,n)=(n-e*t,e) return simp_listdef calc_convergent(simp): convergent=[(0,0)]*len(simp) for i in range(len(simp)): a,b=1,simp[i] for j in range(i): a,b=b,simp[i-1-j]*b+a convergent[i]=(a,b) return convergentPQ,b=iroot(PPQ*PQQ,3)assert bP=PPQ//PQQ=PQQ//PQsimp=simplify_fraction(P,Q,1000)convergent=calc_convergent(simp)for a,b in convergent: if isPrime(b+58) and b.bit_length()==1023: p=b+58 q=(t-p*P+58*P)%Q assert isPrime(q) n=p*q d=inverse(e,(p-1)*(q-1)) m=pow(c,d,n) print(long_to_bytes(m))#b'DASCTF{8f3djoj9wedj2_dkc903cwckckdk}' Solomen's puzzle 1 题目源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# type: ignorem = 257F = Zmod(m)alpha = F(223)PR.&lt;x&gt; = PolynomialRing(F)gx = (x - alpha ^ 0) * (x - alpha ^ 1) * (x - alpha ^ 2) * (x - alpha ^ 3)def encode_block(message): assert isinstance(message, list) f = PR([0] * 4 + message) px = f % gx mx = f - px c = [_ for _ in mx] return c + (8 - len(c)) * [0]def encode(byte_stream): length = len(byte_stream) if length % 4 != 0: padding = (length // 4 + 1) * 4 - length byte_stream += padding * b'\\x00' length += padding code = b'' for i in range(0, length, 4): block = byte_stream[i:i+4] block_code = encode_block([each for each in block]) code += bytes(block_code) return codefrom secret import flag, p, qfrom Crypto.Util.number import bytes_to_long, long_to_bytesfrom random import randrangen = p * qe = 10632528934906371807995216845027219767890923967559690651733628659750564299493611010425615580946665632019547006685100876646048602773295571936276450835367591cipher = bytes_to_long(flag) * e % ncode = encode(long_to_bytes(cipher))code = [each for each in code]for i in range(0, 256, 8): index1 = randrange(4, 8) value1 = randrange(0, 256) index2 = randrange(4, 8) value2 = randrange(0, 256) code[i + index1] = value1 code[i + index2] = value2print(n)print(bytes(code)) 从题目名也可以看出来，本题的考点是Reed-Solomon纠错编码，这是一种基于有限域内多项式运算的纠错码。具体原理可以参考wiki上的解释，看不懂英文的也可以去这篇文章上看看，讲的也很清楚。 在本题中，每个消息块消息长度为4，纠错码长度为4，组成8字节的编码。根据RS纠错码原理，长度为4的纠错码最多能纠正的错误为个。而本题也是在编码的消息部分随机产生了1~2字节的错误，因此纠错码是完全能够将错误全部纠正，得到正确的消息。 因此，本题主要考察的是如何根据编码进行纠错的问题。这一问题在以上的两份链接中也有相关的算法描述（其实是懒得贴公式）。先计算编码的syndrome值，然后根据syndrome值计算得到一个error locator向量，从而可以算出发生error的位置，最后代入到error locator多项式可以求出error value。 注意到编码中错误的个数是不确定的，我直接枚举了。 解题脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from Crypto.Util.number import *from hashlib import md5enc=b'\\xb9$5.&gt;\\xff\\xe3S\\xc91\\xb2\\xeb\\x1byR(\\x12{\\xc4\\xbf\\xa4wo|\\xc5-;\\xc9\\xc9S[\\xaeX\\xad\\xf0\\xef@\\x1c\\x87]\\x9a\\xb9:\\x8cu\\xa5\\xe3EA&lt;\"\\xfd\\x9a\\xbfqB\\x94\\xc3R\\x95\\xd5\\xbd\\xd0\\x10u\\x10\\xe3\\xa5\"S\\xed\\xd0\\xf8\\x02\\xbf\\x124A~1]\\xceP\\xdf\\xf2Cr1\\x93\\xacw\\x03\\tQe\\xcc2b\\xbf\\x0f\\x92\\xad\\x19\\x00\\xab|\\xf3\\xc9\\x9b&amp;I%\\xf5\\x9b#\\xf7\\xa2\\xcb\\xb1\\x0c\\xee\\xb56\\xd5\\xd2\\xd5[?^\\x9d\\x8b\\x93\\xbe\\x832\\xee\\xa9\\xa5\\x83$\\xe9\\xe5\\x95\\x01\\xd6\\x9f\\xad\\x1f\\x90\\xc3]aL\\x10\\x07{#4i^\\xae\\xdf|\\x9f\\x94\\xf4\\xaf\\x06R\\x86j&amp;\\xeb\\x0b\\x06\\xcf\\xb2\\x8e\\xb4\\xb9s\\x97[\\xf1ip\\x06\\xf8\\xfdFs\\xf1`\\xc6\\x82\\xd8\\xce\\xf6\\x95{\\xe3\\x8cQ\\xed\\xef\\xe9\\xb9\\'\\x19\\xdf^\\xc8\\x81\\xde\\x1fQ\\x1e\\x86\\xda\\xf8\\xfd4M0#\\xef\\x8a\\xe9\\xe5\\xfc\\xe2\\xe3\\xe6\\xd0e\\xce\\xe1\\x0b\\x9eM\\x07\\xc2Y\\xf8B\\xe1\\xde\\xfaP\\xe9\\x9d\\xde\\xc3\\xe3C\\xa5'e = 10632528934906371807995216845027219767890923967559690651733628659750564299493611010425615580946665632019547006685100876646048602773295571936276450835367591n = 94257413713770111563970534929325680923943690882102478219183863722026590313165304301118258536360712467357451726680293716779730218553691126214750969333228034756948476572806064756873382054384808713137658321644158757777088916851366208046581218865015163572359836440643828462291397248680038931998325006839692797347m = 257F = Zmod(m)alpha = F(223)PR.&lt;x&gt; = PolynomialRing(F)gx = (x - alpha ^ 0) * (x - alpha ^ 1) * (x - alpha ^ 2) * (x - alpha ^ 3)def get_syndromes(mx): return [mx(alpha^i)for i in range(4)]def get_locator(synd,v): if v==2: m=Matrix([[synd[0],synd[1]],[synd[1],synd[2]]]) vec=vector([-synd[2],-synd[3]]) return list(m^-1*vec) else: return F((-synd[1])*synd[0]^-1)def get_pos(loc,v): if v==2: pos=[] for i in range(8): xx=alpha^(-i) if F(1+loc[1]*xx+loc[0]*xx^2)==0: pos.append(i) return [ alpha^i for i in pos] else: res=F(-loc^-1) return [F(res^-1)]def get_err_val(synd,pos,v): if v==2: m=Matrix(F,[[pos[0]^0,pos[1]^0],[pos[0]^1,pos[1]^1]]) v=vector([synd[0],synd[1]]) return list(m^-1*v) else: return [F(synd[0])]def decode_block(block): mx=PR(list(block)) synd=get_syndromes(mx) for v in [2,1]: try: locator=get_locator(synd,v) pos=get_pos(locator,v) arr=[alpha^i for i in range(8)] err_idx=[ arr.index(t) for t in pos] err_val=get_err_val(synd,pos,v) err=[0]*8 for val,i in zip(err_val,err_idx): err[i]=val plain=mx-PR(err) return bytes(list(plain))[4:8] break except Exception as e: #print(e) continuedef decode(enc): plain=b'' for i in range(0,len(enc),8): block=enc[i:i+8] plain+=decode_block(block) return plaindec=decode(enc)flag=bytes_to_long(dec)*inverse(e,n)%nflag=long_to_bytes(flag)print(flag)flag='DASCTF{%s}'%md5(flag).hexdigest()print(flag)#b'DASCTF{What_a_funny_rsa_question_posted_by_Reed_and_Solomen_LOL_HHHHHH}'#DASCTF{4e4fc02d88b0c8f66c924489e1bf58ea} NovelSystem2 题目源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from Crypto.Util.number import *from gmpy2 import *from uuid import uuid4from flag import flagclass NovelSystem: def __init__(self, delta): self.p = getPrime(delta &gt;&gt; 1) self.q = getPrime(delta &gt;&gt; 1) self.N = self.p * self.q self.beta = 0.397 self.psi = (self.p ** 2 + self.p + 1) * (self.q ** 2 + self.q + 1) self.e, self.d = self.generate_key(delta) self.r = getPrime(delta % delta.bit_length()) def generate_key(self, delta): delta = int(delta * self.beta) d = getPrime(delta) e = invert(d, self.psi) return (e, d) def print_pk(self): print(\"pk:\", (self.N, int(self.e), self.r)) def print_sk(self): print(\"sk:\", (self.N, self.p, self.q, self.e, self.d)) def add_(self, a, b): m, n = a k, l = b if a[1] == 0: a, b = b, a m, n, k, l = k, l, m, n if l == 0: if n == 0: return (m * k, m + k) if (n + k) % self.N == 0: if (m - n ** 2) % self.N == 0: return (0, 0) return ((m * k + self.r) * invert(m - n * n) % self.N, 0) return ((m * k + self.r) * invert(n + k, self.N) % self.N, (m + n * k) * invert(n + k,self.N) % self.N) if (m + k + n * l) % self.N != 0: return ((m * k + (n + l) * self.r) * invert(m + k + n * l, self.N)%self.N,(n * k + m * l + self.r) * invert(m + k + n * l, self.N) % self.N) if (n * k + m * l + self.r) % self.N == 0: return (0, 0) return ((m * k + (n + l) * self.r) * invert(n * k + m * l + self.r, self.N) % self.N, 0) def mul_(self, a, n): ans = (0, 0) while n &gt; 0: if n &amp; 1 == 1: ans = self.add_(ans, a) a = self.add_(a, a) n //= 2 return ans def encrypt(self, m): return self.mul_(m, self.e) def decrypt(self, c): return self.mul_(c, self.d)delta = 1024enc = NovelSystem(delta)m = bytes_to_long(flag[:len(flag) // 2]), bytes_to_long(flag[len(flag) // 2:])c = enc.encrypt(m)enc.print_pk()print(c)assert enc.decrypt(c) == m 这题是RSA的一种变种，其中的phi变成了。 经过一番搜索发现，该系统是Murru and Saettone提出的一种新的类RSA加密系统。其方案原文链接在此。然而，这一RSA变体形式仍然可以被传统的Boneh and Durfee等攻击手法攻击。攻击方案在这篇论文中有详细的描述。文中分析到，只要满足，就可以利用 small inverse problem对进行多项式时间内分解。 本来尝试手动写一下攻击的实现，结果无意间找到原题了，原题是[pbCTF 2021]Yet Another RSA，连参数都没怎么改，好家伙！ 解题脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143from Crypto.Util.number import *from gmpy2 import inverte=3569709831456961963983317856906282564247794656174883346551318455409781951821532194464316039706968856000098892463123452801581913760419867217744612993876726508565953876218527986879338419527071132882516845467078252901861510834762733680624403662683842157212966883670782784707420186939792539380416673702618954148609178781352393489552193742869735649479707631323667621294737562886946346783459713562739324444015141587968954791790724386091523034752910330271202144122827876441229219899077622471534860855412052877175120218922873300885113936346989198403927493848984768217738562507350427274074810257890679068944519650350540061773N=69608791192421919283757675475568920773353852553984294535246714322217147926140334786382671447161809319059757926660104907264892471513691210713164936055575369238706600340586833164515933300246888063235136692968128246137215938114060492757345025435557818940819819146315427528432401269318798897677955790143951114837P.&lt;x, y&gt; = PolynomialRing(ZZ)m = 4t = 2X = int(N ^ 0.4)Y = 3 * int(N ^ 0.5)a = N + 1b = N^2 - N + 1f = x * (y^2 + a * y + b) + 1gs = []for k in range(m + 1): for i in range(k, m + 1): for j in range(2 * k, 2 * k + 2): g = x^(i - k) * y^(j - 2 * k) * f^k * e^(m - k) gs.append((i, j, k, g)) i = k for j in range(2 * k + 2, 2 * k + t + 1): g = x^(i - k) * y^(j - 2 * k) * f^k * e^(m - k) gs.append((i, j, k, g))gs.sort()monomials = []for tup in gs: for v in tup[-1].monomials(): if v not in monomials: monomials.append(v)mat = [[0 for j in range(len(monomials))] for i in range(len(gs))]for i, tup in enumerate(gs): for j, mono in enumerate(monomials): mat[i][j] = tup[-1].monomial_coefficient(mono) * mono(X, Y)mat = Matrix(ZZ, mat)mat = mat.LLL()pols = []for i in range(len(gs)): f = sum(mat[i, k] * monomials[k] / monomials[k](X, Y) for k in range(len(monomials))) pols.append(f)found = Falsefor i in range(len(gs)): for j in range(i + 1, len(gs)): f1, f2 = pols[i], pols[j] rr = f1.resultant(f2) if rr.is_zero() or rr.monomials() == [1]: continue else: try: PR.&lt;q&gt; = PolynomialRing(ZZ) rr = rr(q, q) soly = int(rr.roots()[0][0]) ss = f1(q, soly) solx = int(ss.roots()[0][0]) print(i, j) print(solx, soly) assert f1(solx, soly) == 0 assert f2(solx, soly) == 0 found = True except: pass if found: break if found: breakb, c = soly, NDsqrt = int(sqrt(b^2 - 4*c))p, q = (b + Dsqrt) // 2, (b - Dsqrt) // 2assert p * q == Nphi = (p**2 + p + 1) * (q**2 + q + 1)d = inverse(e, phi)class NovelSystem: def __init__(self, p, q, e, d): self.p = p self.q = q self.N = self.p * self.q self.beta = 0.397 self.psi = (self.p ** 2 + self.p + 1) * (self.q ** 2 + self.q + 1) self.e, self.d = e, d self.r = 3 def add_(self, a, b): m, n = a k, l = b if a[1] == 0: a, b = b, a m, n, k, l = k, l, m, n if l == 0: if n == 0: return (m * k, m + k) if (n + k) % self.N == 0: if (m - n ** 2) % self.N == 0: return (0, 0) return ((m * k + self.r) * invert(m - n * n) % self.N, 0) return ((m * k + self.r) * invert(n + k, self.N) % self.N, (m + n * k) * invert(n + k,self.N) % self.N) if (m + k + n * l) % self.N != 0: return ((m * k + (n + l) * self.r) * invert(m + k + n * l, self.N)%self.N,(n * k + m * l + self.r) * invert(m + k + n * l, self.N) % self.N) if (n * k + m * l + self.r) % self.N == 0: return (0, 0) return ((m * k + (n + l) * self.r) * invert(n * k + m * l + self.r, self.N) % self.N, 0) def mul_(self, a, n): ans = (0, 0) while n &gt; 0: if n &amp; 1 == 1: ans = self.add_(ans, a) a = self.add_(a, a) n //= 2 return ans def encrypt(self, m): return self.mul_(m, self.e) def decrypt(self, c): return self.mul_(c, self.d)c = (25277872308079622747549210576460613586229133947234593535200353386990766871354231190884983744062724190757790170095336476433339679661865115249940491581950905446714526508336734968117122923367321009658430492676221613955154012709104353264746945809594342072744903918483080444098810305069478604650812993367066108686, 23837611977059204694294310415628596206205358541193793076161113947121055317488611201828968875769165810136018932772918536959013421962176622562932517080185242296377551991015543007194938521921909070483342042300905806379510158998331097627686209024554054114596970966269941945120227200103961459438854583220408434182)enc = NovelSystem(p,q,e,d)m = enc.decrypt(c)print(long_to_bytes(m[0]) + long_to_bytes(m[1]))#b'DASCTF{a1a4a518320a469088c64aa4fbc22438}'","link":"/202209/ef27fca5.html"},{"title":"N1CTF2022 Crypto赛题复现","text":"题目非常好，总共只有三道题，比赛时都卡在不同的地方没解出来。赛后看了一些大佬的思路尝试进行了复现，这里把复现的过程做一下记录和总结。 brand_new_checkin 从题目描述可以知道改题是基于[CakeCTF2022]brand_new_crypto的改编。题目源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041from Crypto.Util.number import *from random import getrandbitsfrom secret import flagdef keygen(): p = getPrime(512) q = getPrime(512) n = p * q phi = (p-1)*(q-1) while True: a = getrandbits(1024) b = phi + 1 - a s = getrandbits(1024) t = -s*a * inverse(b, phi) % phi if GCD(b, phi) == 1: break return (s, t, n), (a, b, n)def enc(m, k): s, t, n = k r = getrandbits(1024) return m * pow(r, s, n) % n, m * pow(r, t, n) % npubkey, privkey = keygen()flag = pow(bytes_to_long(flag), 0x10001, pubkey[2])c = []for m in long_to_bytes(flag): c1, c2 = enc(m, pubkey) c.append((c1, c2))print(pubkey)print(c) 与原题的区别在于，在原题加密方式的前面，多了一层rsa的加密。 首先肯定得拿到rsa加密的密文。我们观察到程序中是逐字节进行的enc操作，那么这为我们按字节逐个爆破提供了可能。那么怎么去爆破呢？（其实这一部分在网上已经有题解了，有多种做法） 根据题目有： (s, t)是公钥，(a, b)是私钥。由于产生密文时，r是随机数未知的，因此考虑消去r的影响。做如下计算： 因此爆破单字节m的256种可能情况去验证该等式即可。然后就能拿到rsa的密文。 然而题目似乎没有给出更多有用的能够去分解n的信息，a和b也不能求出来。到这里我当时的思路就没有了。进行了一些尝试，可以求出每次r的值，但好像也无济于事。 赛后看别人的思路一瞬间就懂了，我是真滴眼瞎，这么多个getrandbits我没注意到，这不是妥妥的mt19937随机数预测吗。再扫一眼题目，r是1024bits可以计算，且足够多，那就确认无疑了。 然后是关于r的计算。这里由于s和t是互质的，我们可以通过扩展欧几里得算法计算出使得的A和B。然后做如下计算： 因此我们可以拿到计算每一个字节m所使用的r。为了进行预测，我们需要个r的值，然而实际计算出的数量远比这个多，已经足够了，取前20个即可。 复现时发现这里还有一个比较坑的点，这里的r是模n下计算出来的，而实际r产生时虽然与n一样是1024bits，但和n没有任何关系，也就是说r是可能大于n的。因此这里算出的r有小概率不是准确值，对于每个r需要在1024bits范围内进行小规模的枚举爆破。 然后本题的随机数预测是一个后向的，用到的是ExtendMT19937Predictor。可以通过s来进行验证预测是否正确，然后得到a的值。然后能计算出一个phi的倍数： 用求私钥d，解rsa即可得到flag。 复现解题脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from Crypto.Util.number import *from gmpy2 import gcdextfrom extend_mt19937_predictor import ExtendMT19937Predictorfrom itertools import productfrom tqdm import tqdmdef my_pow(m,e,n): if e&lt;0: return inverse(pow(m,-e,n),n)%n else: return pow(m,e,n)lines=open('output.txt','r').readlines()s,t,n=eval(lines[0])c=eval(lines[1])g,A,B=gcdext(s,t)encflag=[]for c1,c2 in c: tmp=pow(c1,t,n)*inverse(pow(c2,s,n),n)%n for m in range(256): if my_pow(m,t-s,n)==tmp: encflag.append(m) breakencflag=bytes_to_long(bytes(encflag))print(encflag)#5808031027043628162680151939451046896318461702606899637261519628597633638670331617408988305725962951563713997335461555788456061664507614271209312052190146070886646800923406401095648933383421520598567936442062181397887455263188256755970400658783406029792373329955006020555525415893643918145187677700370550761encflag=5808031027043628162680151939451046896318461702606899637261519628597633638670331617408988305725962951563713997335461555788456061664507614271209312052190146070886646800923406401095648933383421520598567936442062181397887455263188256755970400658783406029792373329955006020555525415893643918145187677700370550761mlist=list(long_to_bytes(encflag))possible_rlist=[]for m,cc in zip(mlist,c): c1,c2=cc tmpr=int(my_pow(c1,A,n)*my_pow(c2,B,n)*inverse(my_pow(m,A+B,n),n)%n) assert c1==m*pow(tmpr,s,n)%n assert c2==m*pow(tmpr,t,n)%n if tmpr==0: break tmprlist=[] while tmpr.bit_length()&lt;=1024: tmprlist.append(tmpr) tmpr+=n possible_rlist.append(tmprlist)#624/(1024/32)=19.5possible_rlist=possible_rlist[:20]for rlist in tqdm(product(*possible_rlist)): predictor=ExtendMT19937Predictor() #624=19*(1024/32)+(512/32) for i in range(19): predictor.setrandbits(rlist[i],1024) predictor.setrandbits(rlist[19]&amp;(2**512-1),512) for i in range(624): predictor.backtrack_getrandbits(32) guess_s=predictor.backtrack_getrandbits(1024) if guess_s==s: a=predictor.backtrack_getrandbits(1024) k_phi=s*a+t*(1-a) d=inverse(0x10001,k_phi) flag=long_to_bytes(pow(encflag,d,n)) print(flag) exit(0)#b'n1ctf{5255840f-9140-4479-950f-a3c03fe7f4cd}' ezdlp 题目源码： 123456789101112131415161718192021222324from Crypto.Util.number import *from math import prodfrom secret import flagdef keygen(pbits,kbits,k): p = getPrime(pbits) x = [getPrime(kbits + 1) for i in range(k)] y = prod(x) while 1: r = getPrime(pbits - kbits * k) q = 2 * y * r + 1 if isPrime(q): return p*q, (p, q, r, x)def encrypt(key, message): return pow(0x10001, message, key)key = keygen(512, 24, 20)flag = bytes_to_long(flag)messages = [getPrime(flag.bit_length()) for i in range(47)] + [flag]enc = [encrypt(key[0], message) for message in messages]print(messages[:-1])print(enc) 可以观察到q-1是光滑数，然而题目并没有给出的值，需要先从47组(m, c)中求出n。由于模数n未知，无法直接做模幂运算，也不能直接对一个大数求幂。因此需要用间接法构造出具有因子n的式子。 我们先看最简单的情况，假设有, , 如果与非常接近（假设）, 那么就有, 也即是。通过构造一个比较小的差值来避免了大指数的幂运算。 借用以上思路，回到本题中，我们可以考虑m的线性组合，使t为一个比较小的值，且系数也比较小，从而便于我们计算。这种形式就很熟悉了，可以转化为一个格中的最短向量问题来求解。因此，可以构造如下格矩阵： 通过格基规约，我们可以得到一组短向量，通过观察发现规约出的这一组向量都能用于计算。但注意向量中会有负数出现，由于没有n无法求模逆，需要将正数和负数分开计算。然后每一个向量都能求出一个, 求gcd即可得到n的值。 求出n之后就比较好办了，由于q-1光滑，可以使用Pollard's p-1 方法对n进行分解。然后使用Pohlig-Hellman算法来求解dlp。 在实际操作时，gcd求出的n会带有一些小素数因子，需要先除掉这些因子得到应该是1034bits的n。然后，在使用Pollard's p-1 分解n时，可以直接使用yafu的pm1来分解，不过需要设置一下bound，根据题目参数可以设置为(, )。此外sagemath中的discrete_log方法自带Pohlig-Hellman算法，可以直接使用。 复现整个解题过程如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from Crypto.Util.number import *from itertools import combinationsfrom gmpy2 import gcdextfrom tqdm import tqdmlines=open('output.txt','r').readlines()messages=eval(lines[0])enc=eval(lines[1])e=0x10001l=len(messages)m=matrix(ZZ,l,l+1)for i in range(l): m[i,i]=1 m[i,l]=messages[i]ml=m.LLL()#print(ml)kn=[]for row in ml: v=vector(ZZ,row[:-1]) mes=vector(ZZ,messages) assert v*mes==row[-1] t1,t2=0,0 s1,s2=1,1 for i in range(len(row[:-1])): if row[i]&gt;0: t1+=messages[i]*row[i] s1*=enc[i]^row[i] else: t2+=messages[i]*(-row[i]) s2*=enc[i]^(-row[i]) if row[-1]&lt;0: t1+=(-row[-1]) s1*=e^(-row[-1]) else: t2+=row[-1] s2*=e^row[-1] if t1&lt;t2: kn.append(s1*e^(t2-t1)-s2) else: kn.append(s2*e^(t1-t2)-s1)n=gcd(kn)print(n)'''49611284910337799636686093973628884556519420722411744808788041251053464830295020698422734325291979154664020667752312689941156441913588062021033819091827109198856404394033383330790178899747263327203370892584838961198767774504917946326930691665376634864787990599380909937268721753630966833756746550396165568643515524639508308583115086758244593451557057086091631335435790943219993697350307236788433226079650671638629500149333590709610544282138758930744076756362806343446562260731142938656726337673043604423108674514420668104284015023085322240000000000000000000div by small primes131158523227880830085100826212925738665356578827561846263073537503153187073136528966506785633847097997799377037969243883439723340886038624250936927221630287086602285835045356221763554989140952262353930420392663280482277832613695689454662506372252641564106136178637816827646124189347219273164844809807934422046441'''n=131158523227880830085100826212925738665356578827561846263073537503153187073136528966506785633847097997799377037969243883439723340886038624250936927221630287086602285835045356221763554989140952262353930420392663280482277832613695689454662506372252641564106136178637816827646124189347219273164844809807934422046441c=enc[-1]'''yafu pm1(131158523227880830085100826212925738665356578827561846263073537503153187073136528966506785633847097997799377037969243883439723340886038624250936927221630287086602285835045356221763554989140952262353930420392663280482277832613695689454662506372252641564106136178637816827646124189347219273164844809807934422046441) -B1pm1 33554432 -B2pm1 4294967296'''p=10104420349837363561278745998119091841853342383118385156657416134976061697027571349895988817770681767227605656666215380267313369652920490697343475330713803q=12980311456459934558628309999285260982188754011593109633858685687007370476504059552729490523256867881534711749584157463076269599380216374688443704196597025947res=discrete_log(mod(c,q),mod(e,q))print(long_to_bytes(res))b'n1ctf{1f1b18f9-8523-4584-a8eb-c8b5c9c9433d}' babyecc 题目源码： 1234567891011121314151617181920212223from Crypto.Util.number import *from secret import flagm = Integer(int.from_bytes(flag, 'big'))for _ in range(7): p = getPrime(512) q = getPrime(512) n = p * q while 1: try: a = randint(0,n) b = randint(0,n) Ep = EllipticCurve(GF(p), [a,b]) Gp = Ep.lift_x(m) * 2 Eq = EllipticCurve(GF(q), [a,b]) Gq = Eq.lift_x(m) * 2 y = crt([int(Gp[1]),int(Gq[1])],[p,q]) break except Exception as err: pass print(n, a, b, y) 题目代码很简单就不多作描述了。可以观察到，每一次加密使用的是相同的m，不同的a, b, n。因此可以类比于RSA中的Hastad广播攻击，主要的思想是计算多项式并求crt，然后求根。 这题的主要关键点在于y和m之间关系的一个推导。比赛时就因为这一步出了问题推错了，然后就卡住了。赛后复现又重新推了一遍这个过程，这里把推理过程写一下。 首先假设，。然后我们根据椭圆曲线公式及点的倍乘关系有： 然后把相关变量代入到中： 为了消掉，需要凑出偶数次幂。式子左边有，右边可以直接代入，因此需要两边平方。记： 因此上面的式子可以简写转化为: 其中，除了m之外的变量全部已知。 我们根据这个关系，可以得到7个不同域上的多项式。然后计算这7个多项式的crt得到，其中，的系数由的对应项系数crt计算得出。为7*1024bits，而m大概为344bits（8bits*43，根据flag格式特征），因此可以用small_roots求解。 注意多项式G为12阶，根据coppersmith相关参数的意义，在实际试验过程中，epsilon大概小于0.04左右才能得到结果。 复现解题脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243from Crypto.Util.number import *lines=open('output.txt','r').readlines()enc=[tuple(map(int,lines[i].strip().split(' '))) for i in range(7)]coeffi=[]for i in range(7): n,a,b,y=enc[i] R.&lt;x&gt;=PolynomialRing(Zmod(n)) f=x^3+a*x+b g=3*x^2+a l=64*f^3*y^2 r=12*x*f*g-g^3-8*f^2 F=l-r^2 coeffi.append(F.monic())deg=12ns=[ enc[i][0] for i in range(len(enc))]N=1for n in ns: N*=nCrtlist=[[0 for _ in range(7)] for __ in range(deg+1)]for i in range(7): for j in range(deg+1): Crtlist[j][i]=ZZ(coeffi[i][j])A=[]for i in range(deg+1): A.append(CRT(Crtlist[i],ns))R.&lt;m&gt;=PolynomialRing(Zmod(N))G=R(A)print('Finding Roots')res=G.small_roots(X=2^350,epsilon=1/25)if len(res)&gt;0: print(res) print(long_to_bytes(int(res[0])))else: print('No solution found.')#b'n1ctf{7140f171-5fb5-484d-92f4-9f7ba02c33d0}'","link":"/202211/eb902975.html"},{"title":"NKCTF Crypto wp","text":"小做了一下NKCTF的题。（主要是好久没更了，找点东西水一水刷刷存在感XD） baby_RSA 题目源码： 123456789101112131415161718from Crypto.Util.number import *nbit = 512flag='****************************'p=getPrime(nbit)q=getPrime(nbit)e=65537n=p*qm= bytes_to_long(bytes(flag.encode()))P = pow(m,p,n)Q = pow(m,q,n)N=P*Qphi_N=(P-1)*(Q-1)d=inverse(e,phi_N)dP=d%(P-1)print('n = ',n)print('N = ',N)print('dP = ',dP) 已知和，我们可以把分解出来。 然后根据，有： 从而, 因此有： 根据上式直接coppersmith就能解出来。 解题代码： 12345678910111213141516171819from Crypto.Util.number import *n = 114101396033690088275999670914803472451228154227614098210572767821433470213124900655723605426526569384342101959232900145334500170690603208327913698128445002527020347955300595384752458477749198178791196660625870659540794807018881780680683388008090434114437818447523471527878292741702348454486217652394664664641N = 1159977299277711167607914893426674454199208605107323826176606074354449015203832606569051328721360397610665453513201486235549374869954501563523028914285006850687275382822302821825953121223999268058107278346499657597050468069712686559045712946025472616754027552629008516489090871415609098178522863027127254404804829735621706042266140637592206366042515190385496909533329383212542170504864473944657824502882014292528444918055958758310544435120502872883857209880723535754528096143707324179005292445100655695427777453144657819474805882956064292780031599790769618615908501966912635232746588639924772530057835864082951499028dP = 33967356791272818610254738927769774016289590226681637441101504040121743937150259930712897925893431093938385216227201268238374281750681609796883676743311872905933219290266120756315613501614208779063819499785817502677885240656957036398336462000771885589364702443157120609506628895933862241269347200444629283263e=65537for k in range(1,e): if (e*dP-1)%k==0 and N%((e*dP-1)//k+1)==0: P=(e*dP-1)//k+1 Q=N//P print(f'{P=}') print(f'{Q=}') R.&lt;x&gt;=PolynomialRing(Zmod(n)) f=x^2-(P+Q)*x+P*Q res=f.small_roots()[0] print(long_to_bytes(int(res))) #b'NKCTF{Th1S_a_babyRSA_y0u_are_tql!!!}' ezRSA 题目源码： 1234567891011121314151617181920212223242526272829from Crypto.Util.number import *from secret import flagm1 = bytes_to_long(flag[:len(flag)//3])m2 = bytes_to_long(flag[len(flag)//3:])def gen(): prime_list = [] for i in range(4): prime_list.append(getPrime(512)) return sorted(prime_list)prime_list = gen()p,q,r,t = prime_list[0],prime_list[3],prime_list[1],prime_list[2]e = 65537n = p*q*r*tphi = (p-1)*(q-1)*(r-1)*(t-1)c1 = pow(m1,e,p*q)p1 = getPrime(512)q1 = getPrime(512)N = p1*q1c2 = pow(m2,p1,N)c3 = pow(m2,q1,N)print(f'n = {n}')print(f'phi = {phi}')print(f'c1 = {c1}')print(f'N = {N}')print(f'c2 = {c2}')print(f'c3 = {c3}') flag分成两个部分。m2的解法看似和baby_RSA类似，但直接求发现算不出来，看来需要设置coppersmith参数。因此先要解出m1算出flag长度。 第一部分给了muti-prime的n和phi，因此可以把n分解（网上找个脚本直接跑了），然后解出m1。然后计算出m2的长度为54bytes，从而算出X上限，然后根据，令beta=1，epsilon大约为0.08即可。 解题代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from Crypto.Util.number import *from math import gcdfrom math import isqrtfrom random import randrangen = 8836130216343708623415307573630337110573363595188748983290313549413242332143945452914800845282478216810685733227137911630239808895196748125078747600505626165666334675100147790578546682128517668100858766784733351894480181877144793496927464058323582165412552970999921215333509253052644024478417393146000490808639363681195799826541558906527985336104761974023394438549055804234997654701266967731137282297623426318212701157416397999108259257077847307874122736921265599854976855949680133804464839768470200425669609996841568545945133611190979810786943246285103031363790663362165522662820344917056587244701635831061853354597phi = 8836130216343708623415307573630337110573363595188748983290313549413242332143945452914800845282478216810685733227137911630239808895196748125078747600505622503351461565956106005118029537938273153581675065762015952483687057805462728186901563990429998916382820576211887477098611684072561849314986341226981300596338314989867731725668312057134075244816223120038573374383949718714549930261073576391501671722900294331289082826058292599838631513746370889828026039555245672195833927609280773258978856664434349221972568651378808050580665443131001632395175205804045958846124475183825589672204752895252723130454951830966138888560c1 = 78327207863361017953496121356221173288422862370301396867341957979087627011991738176024643637029313969241151622985226595093079857523487726626882109114134910056673489916408854152274726721451884257677533593174371742411008169082367666168983943358876017521749198218529804830864940274185360506199116451280975188409N = 157202814866563156513184271957553223260772141845129283711146204376449001653397810781717934720804041916333174673656579086498762693983380365527400604554663873045166444369504886603233275868192688995284322277504050322927511160583280269073338415758019142878016084536129741435221345599028001581385308324407324725353c2 = 63355788175487221030596314921407476078592001060627033831694843409637965350474955727383434406640075122932939559532216639739294413008164038257338675094324172634789610307227365830016457714456293397466445820352804725466971828172010276387616894829328491068298742711984800900411277550023220538443014162710037992032c3 = 9266334096866207047544089419994475379619964393206968260875878305040712629590906330073542575719856965053269812924808810766674072615270535207284077081944428011398767330973702305174973148018082513467080087706443512285098600431136743009829009567065760786940706627087366702015319792328141978938111501345426931078e = 65537def factorize_multi_prime(N, phi): \"\"\" Recovers the prime factors from a modulus if Euler's totient is known. This method works for a modulus consisting of any number of primes, but is considerably be slower than factorize. More information: Hinek M. J., Low M. K., Teske E., \"On Some Attacks on Multi-prime RSA\" (Section 3) :param N: the modulus :param phi: Euler's totient, the order of the multiplicative group modulo N :return: a tuple containing the prime factors \"\"\" prime_factors = set() factors = [N] while len(factors) &gt; 0: # Element to factorize. N = factors[0] w = randrange(2, N - 1) i = 1 while phi % (2 ** i) == 0: sqrt_1 = pow(w, phi // (2 ** i), N) if sqrt_1 &gt; 1 and sqrt_1 != N - 1: # We can remove the element to factorize now, because we have a factorization. factors = factors[1:] p = gcd(N, sqrt_1 + 1) q = N // p if isPrime(p): prime_factors.add(p) elif p &gt; 1: factors.append(p) if isPrime(q): prime_factors.add(q) elif q &gt; 1: factors.append(q) # Continue in the outer loop break i += 1 return tuple(prime_factors)primes=factorize_multi_prime(n,phi)primes=sorted(list(primes))p,q=primes[0],primes[3]d=inverse(e,(p-1)*(q-1))m1=pow(c1,d,p*q)flag1=long_to_bytes(m1)print(flag1)#b'NKCTF{it_i5_e45y_th4t_Kn0wn'print(len(flag1))#27R.&lt;x&gt;=PolynomialRing(Zmod(N))f=x^2-(c2+c3)*x+c2*c3res=f.small_roots(X=2^432,beta=1,epsilon=0.08)flag2=long_to_bytes(int(res[0]))print(flag2)#b'_phi_4nd_N_dec0mp0ses_N_w1th_th3_s4m3_c0mm0n_n_but_pq}'#NKCTF{it_i5_e45y_th4t_Kn0wn_phi_4nd_N_dec0mp0ses_N_w1th_th3_s4m3_c0mm0n_n_but_pq} eZ_Math 题目源码： 123456789101112131415from Crypto.Util.number import getPrime, bytes_to_longfrom secret import BITS, hints, flagp = getPrime(BITS)q = getPrime(BITS)n = p * qprint(f'n = {n}')e = 0x10001c = pow(bytes_to_long(flag), e, n)print(f'c = {c}')print('Give you some boring pows:')for i in range(len(hints)): print(hints[i]) 除了n,e,c之外，输出还给了一些pow计算值： 12345678pow(6, 42762902032363446334121451790132830028099011269558028556333775251728898854654431095595000922138958455510196735338223430882428451914478079186797153527810555787441234842366353864053114538165236037883914332840687123514412294276743506313011532002136735343280737244020115917460801848337792582496228600926958548903290, n) = 4pow(6, 141997416965295486849546892322458652502850390670128808480582247784728456230996812361056958004801816363393016360646922983916999235770803618904474553309200419301820603229504955218189709387942156848904968053547462302189568831762401075340100029630332409419313772378068180267756675141584884876543484516408660699471038, n) = 9pow(6, 163378867981477210016607618217525067516899896304907822758749135410592905658324027908854458465871295591148114728316034699358213461728042658497873130073105697195541220650688132150216266657024774867846925219967805863946774978900772828496605795631400777090954141000078238226487076065753781167791598816872139973922682, n) = 3pow(5, 101651508435846472131121026992982127175369332865677196032272241712711171024515826370577416844824734811581351106736224929238579734879671732717639124571916168742336862493284572465162318403582113621582374924091725060981390318743531229548188092491836655143124663368239422819562367919547196053790207486164506763679128, n) = 4pow(8, 7202269322818255506843028035725052687541091567764933235328308385449791332345247877549905289072216053144576876979686287212194040101112899704499548530779540409356827298148385589812450437990490353926475147376495772639210184768544932563432306664067058309318707174880146258394471096033723193568453520897758319446472, n) = 3pow(6, 64144353048545169501182177685199245042148516904337042834500662877593348281981646643392501383208437683265295103007335146323642677871717118780195730291715833681161852263549530796079671807247854056825871499261030685271618441415115259469517298003205103014921105866030173876191202772506688873744342901390437823354935, n) = 8pow(6, 21381451016181723167060725895066415014049505634779014278166887625864449427327215547797500461069479227755098367669111715441214225957239039593398576763905277893720617421183176932026557269082618018941957166420343561757206147138371753156505766001068367671640368622010057958730400924168896291248114300463479274451645, n) = 2... 那么直接挑两对具有平方关系的值出来，根据指数之间的关系然后GCD即可得到，从而直接算出私钥即可。 解题代码： 12345678910111213141516from Crypto.Util.number import *n = 369520637995317866367336688225182965061898803879373674073832046072914710171302486913303917853881549637806426191970292829598855375370563396182543413674021955181862907847280705741114636854238746612618069619482248639049407507041667720977392421249242597197448360531895206645794505182208390084734779667749657408715621c = 324131338592233305486487416176106472248153652884280898177125443926549710357763331715045582842045967830200123100144721322509500306940560917086108978796500145618443920020112366546853892387011738997522207752873944151628204886591075864677988865335625452099668804529484866900390927644093597772065285222172136374562043e = 0x10001t1=163378867981477210016607618217525067516899896304907822758749135410592905658324027908854458465871295591148114728316034699358213461728042658497873130073105697195541220650688132150216266657024774867846925219967805863946774978900772828496605795631400777090954141000078238226487076065753781167791598816872139973922682t2=141997416965295486849546892322458652502850390670128808480582247784728456230996812361056958004801816363393016360646922983916999235770803618904474553309200419301820603229504955218189709387942156848904968053547462302189568831762401075340100029630332409419313772378068180267756675141584884876543484516408660699471038t3=21381451016181723167060725895066415014049505634779014278166887625864449427327215547797500461069479227755098367669111715441214225957239039593398576763905277893720617421183176932026557269082618018941957166420343561757206147138371753156505766001068367671640368622010057958730400924168896291248114300463479274451645t4=64144353048545169501182177685199245042148516904337042834500662877593348281981646643392501383208437683265295103007335146323642677871717118780195730291715833681161852263549530796079671807247854056825871499261030685271618441415115259469517298003205103014921105866030173876191202772506688873744342901390437823354935kphi=GCD(t1*2-t2,t3*3-t4)print(kphi)d=inverse(e,kphi)m=pow(c,d,n)print(long_to_bytes(m))#b'NKCTF{d15cr373_L0g_15_R3DuC710n_f0R_f4C70r1nG}' ez_polynomial 题目源码： 12345678910111213141516171819#sagefrom Crypto.Util.number import *flag = list(bytearray(''))p = getPrime(16)R.&lt;y&gt; = PolynomialRing(GF(p))while True: P1 = R.random_element(degree=(ZZ.random_element(len(flag), 2*len(flag)))) Q1 = R.random_element(degree=(ZZ.random_element(len(flag), 2*len(flag)))) if P1.is_irreducible() and Q1.is_irreducible(): P = P1 Q = Q1 breake = 65537N = P*QS.&lt;x&gt; = R.quotient(N)c = S(flag) ^ eprint(\"P:\" + str(p) + \"\\n\")print(\"N:\" + str(N) + \"\\n\")print(\"C:\" + str(c)) 多项式RSA。直接脚本梭了。 解题代码： 12345678910111213141516171819202122p= 40031P = PolynomialRing(Zmod(p), name = 'x')x = P.gen()y = P.gen()e = 65537n = 24096*y^93 + 38785*y^92 + 17489*y^91 + 9067*y^90 + 1034*y^89 + 6534*y^88 + 35818*y^87 + 22046*y^86 + 12887*y^85 + 445*y^84 + 26322*y^83 + 37045*y^82 + 4486*y^81 + 3503*y^80 + 1184*y^79 + 38471*y^78 + 8012*y^77 + 36561*y^76 + 19429*y^75 + 35227*y^74 + 10813*y^73 + 26341*y^72 + 29474*y^71 + 2059*y^70 + 16068*y^69 + 31597*y^68 + 14685*y^67 + 9266*y^66 + 31019*y^65 + 6171*y^64 + 385*y^63 + 28986*y^62 + 9912*y^61 + 10632*y^60 + 33741*y^59 + 12634*y^58 + 21179*y^57 + 35548*y^56 + 17894*y^55 + 7152*y^54 + 9440*y^53 + 4004*y^52 + 2600*y^51 + 12281*y^50 + 22*y^49 + 17314*y^48 + 32694*y^47 + 7693*y^46 + 6567*y^45 + 19897*y^44 + 27329*y^43 + 8799*y^42 + 36348*y^41 + 33963*y^40 + 23730*y^39 + 27685*y^38 + 29037*y^37 + 14622*y^36 + 29608*y^35 + 39588*y^34 + 23294*y^33 + 757*y^32 + 20140*y^31 + 19511*y^30 + 1469*y^29 + 3898*y^28 + 6630*y^27 + 19610*y^26 + 11631*y^25 + 7188*y^24 + 11683*y^23 + 35611*y^22 + 37286*y^21 + 32139*y^20 + 20296*y^19 + 36426*y^18 + 25340*y^17 + 36204*y^16 + 37787*y^15 + 31256*y^14 + 505*y^13 + 27508*y^12 + 20885*y^11 + 32037*y^10 + 31236*y^9 + 7929*y^8 + 27195*y^7 + 28980*y^6 + 11863*y^5 + 16025*y^4 + 16389*y^3 + 570*y^2 + 36547*y + 10451c =3552*x^92 + 6082*x^91 + 25295*x^90 + 35988*x^89 + 26052*x^88 + 16987*x^87 + 12854*x^86 + 25117*x^85 + 25800*x^84 + 30297*x^83 + 5589*x^82 + 23233*x^81 + 14449*x^80 + 4712*x^79 + 35719*x^78 + 1696*x^77 + 35653*x^76 + 13995*x^75 + 13715*x^74 + 4578*x^73 + 37366*x^72 + 25260*x^71 + 28865*x^70 + 36120*x^69 + 7047*x^68 + 10497*x^67 + 19160*x^66 + 17939*x^65 + 14850*x^64 + 6705*x^63 + 17805*x^62 + 30083*x^61 + 2400*x^60 + 10685*x^59 + 15272*x^58 + 2225*x^57 + 13194*x^56 + 14251*x^55 + 31016*x^54 + 10189*x^53 + 35040*x^52 + 7042*x^51 + 29206*x^50 + 39363*x^49 + 32608*x^48 + 38614*x^47 + 5528*x^46 + 20119*x^45 + 13439*x^44 + 25468*x^43 + 30056*x^42 + 19720*x^41 + 21808*x^40 + 3712*x^39 + 25243*x^38 + 10606*x^37 + 16247*x^36 + 36106*x^35 + 17287*x^34 + 36276*x^33 + 1407*x^32 + 28839*x^31 + 8459*x^30 + 38863*x^29 + 435*x^28 + 913*x^27 + 36619*x^26 + 15572*x^25 + 9363*x^24 + 36837*x^23 + 17925*x^22 + 38567*x^21 + 38709*x^20 + 13582*x^19 + 35038*x^18 + 31121*x^17 + 8933*x^16 + 1666*x^15 + 21940*x^14 + 25585*x^13 + 840*x^12 + 21938*x^11 + 20143*x^10 + 28507*x^9 + 5947*x^8 + 20289*x^7 + 32196*x^6 + 924*x^5 + 370*x^4 + 14849*x^3 + 10780*x^2 + 14035*x + 15327#分解Nq1, q2 = n.factor()q1, q2 = q1[0], q2[0]#求φ，注意求法，phi = (p**q1.degree() - 1) * (p**q2.degree() - 1)assert gcd(e, phi) == 1d = inverse_mod(e, phi)m = pow(c,d,n)#取多项式系数flag = bytes(m.coefficients())print(\"Flag: \", flag.decode())#NKCTF{We_HaV3_n0th1ng_But_dr3amS} fake_MT &amp; real_MT 不知道为什么出了两个一样的题，没看出来源码有啥区别。用一个脚本都能解。 题目源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import randomimport signaldef guess_number_1(): randoms = [] for _ in range(208): randoms.append(random.getrandbits(96)) print(\"randoms = \"+str(randoms)) number = str(random.getrandbits(96)) guess = str(input(\"Guess after number:\")) if guess != number: print(\"Wrong Number! Guess again.\") exit(0)def guess_number_2(): number = str(random.getrandbits(96)) randoms = [] for _ in range(627): randoms.append(random.getrandbits(32)) print(\"randoms = \"+str(randoms)) guess = str(input(\"Guess pre number:\")) if guess != number: print(\"Wrong Number! Guess again.\") exit(0)def guess_number_3(): def _int32(x): return int(0xFFFFFFFF &amp; x) def init(seed): mt = [0] * 624 mt[0] = seed for i in range(1, 624): mt[i] = _int32(1812433253 * (mt[i - 1] ^ mt[i - 1] &gt;&gt; 30) + i) return mt[-1] number = random.getrandbits(32) print(\"last number = \"+ str(init(number))) guess = int(str(input(\"Guess seed number:\"))) if guess != number: print(\"Wrong Number! Guess again.\") exit(0)def guess_number_4(): def extract_number(y): y = y ^ y &gt;&gt; 11 y = y ^ y &lt;&lt; 7 &amp; 2636928640 y = y ^ y &lt;&lt; 15 &amp; 4022730752 y = y ^ y &gt;&gt; 18 return y&amp;0xffffffff number = random.getrandbits(32) print(\"extract number = \"+ str(extract_number(number))) guess = int(str(input(\"Guess be extracted number:\"))) if guess != number: print(\"Wrong Number! Guess again.\") exit(0) print(\"Welcome to the Mersenne Twister basic challenge. Please try to solve 20 challenges in 60 seconds.\")signal.alarm(60)for i in range(20): print(\"Round: \"+str(i+1)) random.choice([guess_number_1,guess_number_2,guess_number_3,guess_number_4])() print(\"Good job!\")flag = open('/flag').read()print(\"Congratulations on passing the challenge. This is your flag: \" + str(flag)) 需要解决四个跟MT19937随机数有关的问题。问题1是前向预测，问题2是后向预测，这两个直接调库就能解。问题3需要还原初始化种子，我们可以很轻松地写出逆过程。问题4是提取算法，对应库里面的temper方法，直接把面的untemper拿过来解即可。 解题脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *from Crypto.Util.number import *from extend_mt19937_predictor import ExtendMT19937Predictorcontext.log_level = 'debug'sh=remote('node2.yuzhian.com.cn',32881)#sh=process(['python3','task.py'])l64 = lambda :u64(sh.recvuntil(\"\\x7f\")[-6:].ljust(8,\"\\x00\"))l32 = lambda :u32(sh.recvuntil(\"\\xf7\")[-4:].ljust(4,\"\\x00\"))sla = lambda a,b :sh.sendlineafter(str(a),str(b))sa = lambda a,b :sh.sendafter(str(a),str(b))lg = lambda name,data : sh.success(name + \": 0x%x\" % data)se = lambda payload: sh.send(payload)rl = lambda : sh.recvline()rv = lambda n : sh.recv(n)sl = lambda payload: sh.sendline(payload)ru = lambda a :sh.recvuntil(str(a))rud = lambda a :sh.recvuntil(str(a),drop=True)def solve1(rands): pre = ExtendMT19937Predictor() for num in rands: pre.setrandbits(num,96) guess=pre.predict_getrandbits(96) sla('Guess after number:',str(guess))def solve2(rands): pre = ExtendMT19937Predictor() for num in rands: pre.setrandbits(num,32) for _ in rands: pre.backtrack_getrandbits(32) guess=pre.backtrack_getrandbits(96) sla('Guess pre number:',str(guess))def solve3(num): mod=2**32 inv=inverse(1812433253,mod) mt=num for i in range(623,0,-1): mt=((mt-i)*inv)%mod mt=mt^mt&gt;&gt;30 sla('Guess seed number:',str(mt))def solve4(num): def untemper(y): y ^= (y &gt;&gt; 18) y ^= (y &lt;&lt; 15) &amp; 0xefc60000 y ^= ((y &lt;&lt; 7) &amp; 0x9d2c5680) ^ ((y &lt;&lt; 14) &amp; 0x94284000) ^ ((y &lt;&lt; 21) &amp; 0x14200000) ^ ((y &lt;&lt; 28) &amp; 0x10000000) y ^= (y &gt;&gt; 11) ^ (y &gt;&gt; 22) return y sla('Guess be extracted number:',str(untemper(num)))rl()for _ in range(20): rl() line=rl().decode().strip() #print(line) if '[' in line: rands=eval(line.split('randoms = ')[-1].replace('L','')) if len(rands)==208: solve1(rands) elif len(rands)==627: solve2(rands) else: print('error!') exit(0) elif 'last' in line: number=int(line.split('last number = ')[-1].replace('L','')) solve3(number) elif 'extract' in line: number=int(line.split('extract number = ')[-1].replace('L','')) solve4(number) else: print('error!') exit(0) rl()sh.interactive()#NKCTF{29a35b27-b745-4a57-bb5c-b7d67553bf2e} eZ_Bl⊕ck 题目源码： 1234567891011121314151617181920212223from Crypto.Util.strxor import strxor as xorimport osfrom secret import flagdef round(s, k): l, r = s[:16], s[16:] l_, r_ = xor(xor(r, k), l), l return l_ + r_def encode(s, k): t = s for i in range(8): t = round(t, k[i]) return tr = os.urandom(32)print(r)key = [os.urandom(16) for _ in range(8)]print(encode(r, key))m = flag.strip(b'NKCTF{').strip(b'}').replace(b'-',b'')print(encode(m, key)) 定义了一个类似于Feistel结构的轮加密，但里面只涉及到异或运算。通过简单分析可以推出，第轮加密后满足，。其中，是若干轮密钥的异或。而题目提供了一对已知明文和密文，因此可以直接算出第8轮时的，。然后反解flag密文即可。 解题代码： 12345678910111213141516from Crypto.Util.strxor import strxor as xortest=b\"t\\xf7\\xaa\\xac\\x9d\\x88\\xa4\\x8b\\x1f+pA\\x84\\xacHg'\\x07{\\xcc\\x06\\xc4i\\xdd)\\xda\\xc9\\xad\\xa9\\xe8\\x1fi\"enc_test=b\"'{&lt;z}\\x91\\xda\\xc5\\xd5S\\x8b\\xfa\\x9f~]J\\x0f\\xf4\\x9a\\x1e\\xe0\\xef\\x129N\\xe7a\\x928+\\xe0\\xee\"enc_flag=b'8\\x1f\"\\x83B4\\x86)\\xce\\xebq3\\x06\\xa0w\\x16U\\x04M/w\\xa1\\x8f;)M\\xdd~\\x11:\\xe3\\xb3'l0,r0=test[:16],test[16:]l8,r8=enc_test[:16],enc_test[16:]K1=xor(l8,r0)K2=xor(r8,xor(l0,r0))flag2=xor(enc_flag[:16],K1)flag1=xor(xor(enc_flag[16:],K2),flag2)print(flag1+flag2)#b'1ccd5ceec96d4caf8ce59a512b3d0655'#NKCTF{1ccd5cee-c96d-4caf-8ce5-9a512b3d0655} easy_high 题目源码： 1234567891011from Crypto.Util.number import *flag = ''p, q = getPrime(1024), getPrime(1024)N = p * qp0 = p ^ (bytes_to_long(flag)&lt;&lt;444)m = bytes_to_long(flag)c = pow(m, 65537, N)print('c=',c)print('N=',N)print('p0=',p0) p0相当于给出了p的低444位。但是根据相关的攻击理论，p位数泄露需要达到至少一半左右才能用coppersmith攻击。 我们可以猜测flag不超过60字节，即480位，这样的话p0还会泄露出一部分的高位。两者综合起来可以满足coppersmith的要求。因此，只需要爆破猜测flag长度即可。 解题代码： 1234567891011121314151617181920212223from Crypto.Util.number import *c= 4881545863615247924697512170011400857004555681758106351259776881249360423774694437921554056529064037535796844084045263140567168171628832384672612945806728465127954937293787045302307135365408938448006548465000663247116917564500525499976139556325841597810084111303039525833367199565266613007333465332710833102978756654324956219855687611590278570749890543277201538208370370097424105751568285050703167350889953331829275262932104042040526209179357770495596739361176548337593674366015027648541293309465113202672923556991818236011769228078267484362980348613669012975963468592763463397575879215173972436831753615524193609612N= 17192509201635459965397076685948071839556595198733884616568925970608227408244870123644193452116734188924766414178232653941867668088060274364830452998991993756231372252367134508712447410029668020439498980619263308413952840568602285764163331028384281840387206878673090608323292785024372223569438874557728414737773416206032540038861064700108597448191546413236875600906013508022023794395360001242071569785940215873854748631691555516626235191098174739613181230094797844414203694879874212340812119576042962565179579136753839946922829803044355134086779223242080575811804564731938746051591474236147749401914216734714709281349p0= 149263925308155304734002881595820602641174737629551638146384199378753884153459661375931646716325020758837194837271581361322079811468970876532640273110966545339040194118880506352109559900553776706613338890047890747811129988585025948270181264314668772556874718178868209009192010129918138140332707080927643141811plow=p0&amp;(2^444-1)for flaglen in range(20,60): phigh=p0&gt;&gt;(444+8*flaglen) R.&lt;x&gt;=PolynomialRing(Zmod(N)) f=phigh*2^(444+8*flaglen)+x*2^444+plow res=f.monic().small_roots(X=2^(8*flaglen),beta=0.4) if len(res)&gt;0: p=phigh*2^(444+8*flaglen)+res[0]*2^444+plow p=int(p) if N%p==0: q=N//p d=inverse(65537,(p-1)*(q-1)) m=pow(c,d,N) print(long_to_bytes(m)) exit(0)#b'NKCTF{F10wrs_hVe_r3strDay}' Raven 题目源码： 1234567891011121314151617181920212223242526272829#!/usr/bin/env sage# Problem by rec, with a bad raven.import os, hashlibfrom Crypto.Util.number import *from Crypto.Cipher import AESdef Raven(n: int, secret: bytes): H = lambda x: hashlib.md5(os.urandom(8) + x).digest() p = getPrime(728) R.&lt;z&gt; = PolynomialRing(GF(p)) seed = H(secret) f = R( [bytes_to_long(secret)] + [bytes_to_long(H(seed)) for _ in range(n - 1)] ) x = [getRandomRange(2, p - 1) for _ in range(n)] y = [ZZ(f(xi)^2 + getPrime(256)) for xi in x] pairs = list(zip(x, y)) return p, pairsflag = b'#####'key = os.urandom(16)cipher = AES.new(key=key, IV=bytes(range(16)), mode=AES.MODE_CBC)ct = cipher.encrypt(flag + os.urandom(16 - len(flag) % 16))p, pairs = Raven(4, key)print(f\"{p = }\\n{pairs = }\\n{ct = }\") 定义了一个多项式, 其中是要求的值。给了四组数据, 其中为小噪声。这里我们先把展开： 可以观察到系数和噪声均为256位左右，而p为728位，那么应该是用格来解了。根据以上关系，可以构造出格： 利用LLL能够规约出一个短向量。尽管常数项系数有噪声误差，但可以通过其它项系数算出来。 最后AES解密即可。 解题代码： 12345678910111213141516171819202122232425262728293031323334p = 1018551160851728231474335384388576586031917743463656622083024684199383855595168341728561337234276243780407755294430553694832049089534855113774546001494743212076463713621965520780122783825100696968959866614846174188401153pairs = [(615358616404864757405587650175842125441380884418119777842292095751090237848084440177153221092040264723889917863863854377665802549748720692225139890884830475485512763149974948701807492663962748292710803434009673589337265, 84982753624462868217739962129526665082932464631118597651920986288766037499319751354013335054886685186857222944776560264528363811382359242656883760986496856164448940929282013856762706210675691655747370624405968909408102), (528363810186974800127873139379943131424126521611531830591311656948009967709310974894584084912262479395720199930206495204352231804549705720854271566421006481173043064265399467682307971910488405265826107365679757755866812, 496810092723839642457928776423789418365006215801711874210443222720529161066621876103037104247173440072986344011599384793861949574577559989016501090247331146721371126871470611440468688947950954988175225633457347666551944), (68711183101845981499596464753252121346970486988311398916877579778110690480447199642602267233989256728822535174215153145632158860662954277116345331672194812126361911061449082917955000137698138358926301360506687271134873, 995428771589393162202488762223106955302099250561593105620410424291405842350539887383005328242236156038373244928147473800972534658018117705291472213770335998508454938607290279268848513727721410314612261163489156360908800), (61574167546312883246262193556029081771904529137922128124933785599227801608271357738142074310192454183183340219301304405636497744152219785042075198056952749425345561162612590170550454476602892138914473795478531165181812, 618169326093802548516842299173393893046765466917311052414967158839652012130855552015876657514610755108820971877570295328618373296493668146691687291894702228119875561585283226588768969944781923428807766632578060221034862)]ct = b\"|2\\xf0v7\\x05Y\\x89\\r]\\xe93s\\rr)#3\\xe9\\x90%Z\\x9a\\xd9\\x9ck\\xba\\xec]q\\xb8\\xf2'\\xc8e~fL\\xcf\\x93\\x00\\xd6^s-\\xc9\\xd6M\"from Crypto.Util.number import *from Crypto.Cipher import AESfrom gmpy2 import irootFp=GF(p)mat=Matrix(ZZ,12,12)for i in range(8): mat[i,i]=1for i in range(4): mat[i+8,i+8]=pfor i in range(4): x,y=pairs[i] for j in range(7): mat[j,i+8]=ZZ(Fp(x)^j) mat[7,i+8]=-yml=mat.LLL()res=[ -x for x in ml[1]]#print(res)c=int(iroot(int(res[6]),2)[0])b=res[5]//(2*c)a=(res[4]-b*b)//(2*c)s=res[1]//(2*a)key=long_to_bytes(int(s))cipher = AES.new(key=key, IV=bytes(range(16)), mode=AES.MODE_CBC)flag=cipher.decrypt(ct)print(flag)#b'Message from raven: nkctf{..escape..} \\xc2\\x01\\x80\\xd5\\x07\\x10\\x89\\xc7\\x81m' ez_LargeCG 题目源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from gmpy2 import next_primefrom Crypto.Util.number import getPrime, isPrime, bytes_to_longimport randomfrom secret import flagdef init(): primes = [] p = 1 while len(primes) &lt; 100: p = next_prime(p) primes.append(int(p)) return primesdef genMyPrimeA(bits): while True: g = 2 while g &lt; 2 ** bits: g *= random.choice(primes) g += 1 if isPrime(g): return gdef genMyPrimeB(bits): while True: g = 2 while g &lt; 2 ** bits: g *= random.choice(primes) g -= 1 if isPrime(g): return gdef gen(st, n, a, b, c, d): A = [st + 2023, st + 2024, st + 2025] for i in range(6**666): A.append((a * A[-3] + b * A[-2] + c * A[-1] + d) % n) return Aprimes = init()p1 = getPrime(256)print(p1)q1 = 1while p1 &gt; q1: q1 = genMyPrimeA(256)print(q1)p2 = getPrime(256)q2 = 1while p2 &gt; q2: q2 = genMyPrimeB(256)n1 = p1 * q1n2 = p2 * q2print(f'n1 = {n1}')print(f'n2 = {n2}')r = getPrime(512)print(f'r = {r}')A = gen(bytes_to_long(flag), r, p1, q1, p2, q2)print(f'A[-3] = {A[-3]}')print(f'A[-2] = {A[-2]}')print(f'A[-1] = {A[-1]}') 可以发现光滑，光滑，因此可以用相应方法分解。然后gen里面6**666太大，需要转化为矩阵幂进行求解，即： 解题代码： 12345678910111213141516171819202122232425262728293031from Crypto.Util.number import *'''python3 -m primefac -vs -m=p-1 39755206609675677517559022219519767646524455449142889144073217274247893104711318356648198334858966762944109142752432641040037415587397244438634301062818169Z155 = P77 x P78 = 92946439027877993602295703905130336736159270745389239059083263513478865293549 x 427721675251610827084310512123962488210068003845592404231631542730839819224381python3 -m primefac -vs -m=p+1 30725253491966558227957591684441310073288683324213439179377278006583428660031769862224980605664642101191616868994066039054762100886678504154619135365646221Z155 = P78 x P78 = 106481130516780473105954611077340189174861459077145246394800660809527032990637 x 288551157776490110472645044398395422160196115791981535735903775378294599329633'''n1 = 39755206609675677517559022219519767646524455449142889144073217274247893104711318356648198334858966762944109142752432641040037415587397244438634301062818169n2 = 30725253491966558227957591684441310073288683324213439179377278006583428660031769862224980605664642101191616868994066039054762100886678504154619135365646221r = 7948275435515074902473978567170931671982245044864706132834233483354166398627204583162848756424199888842910697874390403881343013872330344844971750121043493A_3 = 6085327340671394838391386566774092636784105046872311226269065664501131836034666722102264842236327898770287752026397099940098916322051606027565395747098434A_2 = 1385551782355619987198268805270109182589006873371541520953112424858566073422289235930944613836387546298080386848159955053303343649615385527645536504580787A_1 = 2529291156468264643335767070801583140819639532551726975314270127875306069067016825677707064451364791677536138503947465612206191051563106705150921639560469p1=92946439027877993602295703905130336736159270745389239059083263513478865293549q1=427721675251610827084310512123962488210068003845592404231631542730839819224381p2=106481130516780473105954611077340189174861459077145246394800660809527032990637q2=288551157776490110472645044398395422160196115791981535735903775378294599329633a,b,c,d=p1,q1,p2,q2mat=[[0,0,a,0],[1,0,b,0],[0,1,c,0],[0,0,1,1]]mat=Matrix(Zmod(r),mat)M=mat^(6**666)v=vector(Zmod(r),[A_3,A_2,A_1,d])res=v*M^-1assert res[0]+1==res[1]flag=long_to_bytes(int(res[0]-2023))print(flag)b'NKCTF{y0u_kN0w_r5A_&amp;_LCg_&amp;_Ma7r1X_s0_w3ll!!!}' baby_classical 题目源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import stringimport reimport numpy as npflag = ''print('flag length:',len(flag))dic = string.ascii_uppercase+string.ascii_lowercase+string.digits+'+/'f1nd = lambda x : dic.find(x)class KeyEncryption: def __init__(self, m: int, fillchar: str=\"z\", key: np.ndarray=None): self.m = m self.key = key self.dicn2s = {i: dic[i] for i in range(64)} self.dics2n = dict(zip(self.dicn2s.values(), self.dicn2s.keys())) self.fillchar = self.dics2n[fillchar] def setM(self, m: int) -&gt; None: assert m &gt; 0 self.m = m def setKey(self, key: np.ndarray=None) -&gt; None: if key is None: while key is None or KeyEncryption.modInv(np.linalg.det(key)) == -1: key = np.random.randint(0, 65, size=(self.m, self.m)) print(\"random matrix：\\n\", key) else: assert KeyEncryption.modInv(np.linalg.det(key)) != -1 self.key = key @staticmethod def modInv(x: int): y = 0 while y &lt; 64: y += 1 if (x * y) % 64 == 1: return y return -1 def _loopCrypt(self, long: np.ndarray, K: np.ndarray) -&gt; np.ndarray: ans = np.array([]) for i in range(long.shape[0] // self.m): ans = np.mod(np.hstack(( ans, np.dot(long[i*self.m:i*self.m+self.m], K) )), 64) return ans.astype(np.int64) def encrypt(self, plaintext: np.ndarray): assert self.m !=None and self.key is not None if plaintext.shape[0] % self.m: plaintext = np.hstack(( plaintext, [self.fillchar] *(self.m - plaintext.shape[0] % self.m) )) return self._loopCrypt(plaintext, self.key) def translate(self, s, to: str): if to == \"text\": return \"\".join([self.dicn2s[si] for si in s]) elif to == \"num\": s = s.replace(\" \", \"\") return np.array([self.dics2n[si] for si in s])def getKey(key): he = KeyEncryption(m=3) he.setKey() nums = he.translate(key, \"num\") res = he.encrypt(nums) enkey = ''.join(dic[i] for i in res.tolist()) print('Encrypt key:',enkey) return enkeyif __name__ == '__main__': fir1 = ' '.join(map(lambda _:_[::-1],re.split(\"[ { _ } ]\" , flag.swapcase()))) ciphertext1 = '' key = \"\" enkey = getKey(key) _enkey=[f1nd(i) for i in key] print('key lengeh:',len(_enkey)) j = 0 for i in fir1: if f1nd(i)&gt;=0: ciphertext1 += dic[(f1nd(i) + _enkey[j % len(_enkey)])%64] else: ciphertext1 += i j += 1 ciphertext = ciphertext1.replace(' ','_') print('ciphertext:%s{%s}' % (ciphertext[0:5],ciphertext[6:-1])) 分析源码可以知道主要是对flag做了一个类似于维吉尼亚的移位，然而不知道key。需要先根据encrypt key来求出key。而在_loopCrypt里，把key的每一个子块与一个3*3的矩阵进行了相乘来返回对应的密文。而这个矩阵是已知的，那么解密直接乘上逆矩阵就好了。求出key之后，把flag密文移位回来，并做一些形式的变换即可。 解题代码： 123456789101112131415161718192021222324252627282930313233343536373839import stringimport reimport numpy as npdic = string.ascii_uppercase+string.ascii_lowercase+string.digits+'+/'f1nd = lambda x : dic.find(x)n=64m=3Zn=Zmod(n)mat=Matrix(Zn,[[13,37,10], [15,17,41], [13,0,10]])enc_key='pVvRe/G08rLhfwa'ct='1k2Pe{24seBl4_a6Ot_fp7O1_eHk_Plg3EF_g/JtIonut4/}'enc_key_block=[ enc_key[m*i:m*(i+1)] for i in range(len(enc_key)//m)]key=''for block in enc_key_block: enc_num=vector(Zn,[f1nd(x) for x in block]) m_num=enc_num*mat^-1 key+=''.join([ dic[m] for m in m_num])print(key)#W3ar3N0wayBackzkey=key[:14]_enkey=[f1nd(i) for i in key]tmp=''for i,c in enumerate(ct): if c in dic: tmp+=dic[(f1nd(c)-_enkey[i%len(_enkey)])%64] else: tmp+=cprint(tmp)flag=' '.join(map(lambda _:_[::-1],re.split(\"[ { _ } ]\" , tmp.swapcase())))flag=flag.replace(' ','_')flag='%s{%s}'%(flag[:5],flag[6:-1])print(flag)#NKCTF{ClaSsic_c0de_d0l1s_aRe_r3a1ly_int3reSting} complex_matrix 题目源码： 12345678910111213141516171819from Crypto.Util.number import *import gmpy2 as gyflag = ''k = 400p, q = getPrime(741), getPrime(741)N = p * qphi = (p-1) * (q-1)_flag = bytes_to_long(flag)p, q = getPrime(1024), getPrime(1024)d_array = [getPrime(k) for _ in range(4)] e_array = [inverse(i, phi) for i in d_array]c = pow(_flag, 65537, N)print('N:',N)print('e:',e_array)print('c:',c)#N: 71841248095369087024928175623295380241516644434969868335504061065977014103487197287619667598363486210886674500469383623511906399909335989202774281795855975972913438448899231650449810696539722877903606541112937729384851506921675290984316325565141178015123381439392534417225128922398194700511937668809140024838070124095703585627058463137549632965723304713166804084673075651182998654091113119667582720831809458721072371364839503563819080226784026253#e: [65128799196671634905309494529154568614228788035735808211836905142007976099865571126946706559109393187772126407982007858423859147772762638898854472065889939549916077695303157760259717113616428849798058080633047516455513870697383339784816006154279428812359241282979297285283850338964993773227397528608557211742425548651971558377656644211835094019462699301650412862894391885325969143805924684662849869947172175608502179438901337558870349697233790535, 58756559706647121529575085912021603170286163639572075337348109911506627489265537716060463072086480156516641723700802217411122982693536541892986623158818442274840863016647800896033363360822503445344748132842451806511693779600370832206455202293028402486647422212959763287987847280322100701242139127654031151565924132562837893975505159702015125483479126108892709063135006366792197127007229210558758401679638300464111782814561428899998471531067163715, 34828685390969672139784723764579499920301439564705391196519314224159563070870933754477650614819514127121146216049444888554338415587165719098661141454627820126445291802801256297252654045398330613075575527685542980264993711077876535643646746742646371967302159565887123638001580042027272379341650995728849759541960087953160211696369079708787543303742132161742979856720539914370868829868891655221361545648778590685232034703220732697083024449894197969, 26717968456600556973167180286909817773394160817933525240720067057464671317174201540556176814203780603153696663101158205367554829261808020426363683474848952397963507069306452835776851274959389849223566030857588019845781623271395012194869024566879791449466064832273531795430185178486425688475688634844530106740480643866537205900809400383304665727460014210405339697947582657505028211149470787536144302545259243549176816653560626044921521516818788487]#c: 39297018404565022956251803918747154798377576057123078716166221329195959669756819453426741569480551313085435037629493881038383709458043802420338889323233368852331387845200216275712388921820794980987541224782392553528127093154957890356084331463340193478391679540506421250562554424770350351514435220782124981277580072039637811543914983033300225131364246910828188727043248991987332274929827173923543187017105236008487756190002204169623313222748976369 尝试了一下单组数据使用boneh durfee attack,发现行不通。然后发现是muti public exponent with small private exponent and common modulus，针对该问题的攻击由Aono提出，paper在此。 crypto-attacks仓库已经集成了有该攻击的实现，就拿过来改改用用咯。 这题代码就不贴了，大家自行摸索吧。 1b'NKCTF{F10w3r_Hav3_r3start_Day_N0_Man_iS_Y0ung_Aga1n}'","link":"/202303/acd9a838.html"},{"title":"ByteCTF2022 Crypto wp","text":"周末撞上MTCTF决赛了，ByteCTF没仔细研究。把做出的两道随便写写，等官方wp出来再学习学习吧~ Choose_U_Flag 题目源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import astimport randomimport signalimport stringimport osimport numpy as npfrom sympy import ZZ, Polyfrom sympy.abc import xfrom ntru import NTRUCipherdef exitHandler(signum, frame): print(\"timeout\") exit()signal.signal(signal.SIGALRM, exitHandler)signal.alarm(30)flag = os.environ.get(\"CTF_CHALLENGE_FLAG\")N = 107p = 3q = 64cipher = NTRUCipher(N, p, q)cipher.generate()print(f\"[+]h_poly: {cipher.h_poly.all_coeffs()}\")random_key = ''.join(random.sample(string.printable, 12))key_arr = np.unpackbits(np.frombuffer(random_key.encode(), dtype=np.uint8))key_enc = cipher.encrypt(Poly(key_arr, x).set_domain(ZZ))key_coeffs = key_enc.all_coeffs()print(f\"[+]key coeffs: {key_coeffs}\")dec_data = input(\"decrypt data &gt; \")dec_arr = ast.literal_eval(dec_data)if dec_arr == key_coeffs: exit(-1)dec = cipher.decrypt(Poly(dec_arr, x).set_domain(ZZ))dec_coeffs = dec.all_coeffs()print(f\"[+]decrypt coeffs: {dec_coeffs}\")while N &gt; 0: try: u_key = input(\"u key &gt; \") if u_key == random_key: print(flag) exit(-1) else: print(\"key err\") except: print(\"input err\") N = N - 1 NTRU加密，但是有一次decrypt的机会！题目只限制了dec_arr和key_coeffs不相等，由于加密过程, 其中m是二进制的且没有乘任何系数，那么我们偷偷在key_coeffs最后一位减一，解密得到的会是什么呢，嘿嘿。 这题应该是非预期了。听说预期解使用NTRU的选择密文攻击来做，参考论文。 解题脚本（可能会报错，多试几遍）： 1234567891011121314151617181920212223242526272829303132333435363738from Crypto.Util.number import *from Crypto.Hash import SHA3_256from Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadfrom pwn import *CHALLENGE_ID = 'e644151c5bb33cebf605f12f0dd86a2e'sh = process(['./wscat', '--endpoint', 'wss://telnet.2022.capturetheflag.fun/ws/' + CHALLENGE_ID])sla = lambda a,b :sh.sendlineafter(str(a),str(b))sa = lambda a,b :sh.sendafter(str(a),str(b))lg = lambda name,data : sh.success(name + \": 0x%x\" % data)se = lambda payload: sh.send(payload)rl = lambda : sh.recvline()rv = lambda n : sh.recv(n)sl = lambda payload: sh.sendline(payload)ru = lambda a :sh.recvuntil(str(a))rud = lambda a :sh.recvuntil(str(a),drop=True)rud('[+]h_poly: ')h = eval(rl().strip())rud('[+]key coeffs: ')key_enc=eval(rl().strip())print(h)print(key_enc)my_enc=key_enc[:len(key_enc)-1]+[key_enc[-1]+1]sla('decrypt data &gt; ',str(my_enc))rud('[+]decrypt coeffs: ')my_dec=eval(rl().strip())my_dec=''.join(map(str,my_dec))key_tmp=long_to_bytes(int(my_dec,2))key_tmp=list(key_tmp)key_tmp[-1]-=1key=bytes(key_tmp).decode('utf-8')sla('u key &gt; ',key)sh.interactive()#ByteCTF{9e8876cc-9eae-4178-b2b4-9a4c7ae0941f} Compare 题目源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from Crypto.Util.number import getPrime, getRandomNBitInteger, inversefrom fractions import Fractionfrom gmpy2 import lcmimport reN = 512safe_expr = re.compile(r'^([-+*/0-9.~%^&amp;()=|&lt;&gt;]|and|or|not|MSG)+$')def encode(m, n, g): r = getRandomNBitInteger(N) c = pow(g, m, n*n) * pow(r, n, n*n) % (n*n) return cdef decode(c, n, l, u): return int(Fraction(pow(c, l, n * n) - 1, n) * u % n)def round(expr): p = getPrime(N) q = getPrime(N) n = p * q g = getRandomNBitInteger(N) print('n =', n) print('g =', g) a = getRandomNBitInteger(N) b = getRandomNBitInteger(N) print('a =', encode(a, n, g)) print('b =', encode(b, n, g)) msg = int(input(\"msg = \")) l = int(lcm(p - 1, q - 1)) u = inverse(Fraction(pow(g, l, n * n) - 1, n), n) return (a &gt; b) is bool(eval(expr, None, {'MSG': decode(msg, n, l, u)}))def main(): expr = input('Hello, Give me your expr: ') expr = re.sub(r'\\s', '', expr) if safe_expr.match(expr) is None: raise Exception('Hacker?') for i in range(100): print('Round:', i) try: assert round(expr) except: print('You lost.') break else: print('Congratulations!') print(open('/flag').read())if __name__ == '__main__': main() 本题是一个Paillier同态加密，考察的是同态函数中对加密数据的大小比较。在题目中，先给出公钥相关信息和待比较数据a和b的加密值，然后有一次任意解密的机会，解密出的值存放在MSG变量中，但不会输出。我们需要在每轮中使用同一个表达式来确定a和b的大小关系。题目对eval中的表达式进行了过滤，我们只能使用MSG和常量之间的运算式。 假设同态加密函数为, 首先我们构造： 这里这样构造的原因是，当b&lt;a时，x为N位；当b&gt;a时，x为N+1位。 然后我们加上一个固定常量r，其比特长度略大于x即可，我这里取。 接下来计算： 然后把这个值算出来丢给题中解密，也即是令。 接着计算两个值： 当b&lt;a时，有，此时c和d的值是相同的；当b&gt;a时，有，此时d的值会比c刚好大1。至此，我们可以根据c和d的关系来判断a和b的大小。 解题脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243from Crypto.Util.number import *from pwn import *CHALLENGE_ID = 'bf3735ea56c9efa904820ce1dc898f80'sh = process(['./wscat', '--endpoint', 'wss://telnet.2022.capturetheflag.fun/ws/' + CHALLENGE_ID])context.log_level='debug'sla = lambda a,b :sh.sendlineafter(str(a),str(b))sa = lambda a,b :sh.sendafter(str(a),str(b))lg = lambda name,data : sh.success(name + \": 0x%x\" % data)se = lambda payload: sh.send(payload)rl = lambda : sh.recvline()rv = lambda n : sh.recv(n)sl = lambda payload: sh.sendline(payload)ru = lambda a :sh.recvuntil(str(a))rud = lambda a :sh.recvuntil(str(a),drop=True)N=512def encode(m, n, g): r = getRandomNBitInteger(N) c = pow(g, m, n*n) * pow(r, n, n*n) % (n*n) return cdef solve_round(): rud('n =') n=int(rl().strip()) rud('g =') g=int(rl().strip()) rud('a =') enca=int(rl().strip()) rud('b =') encb=int(rl().strip()) encx=encb*encode(2**N,n,g)*inverse(enca,n**2)%n**2 r=2**(N+10) encz=encx*encode(r,n,g)%n**2 sla('msg = ',str(encz))expr='2**10==MSG//(2**512)'sla('expr: ',expr)for _ in range(100): solve_round()sh.interactive()#ByteCTF{ed4dad6f-45a4-41bf-a538-fd5d0754b3df}","link":"/202209/986c53b5.html"},{"title":"NepCTF2023 Crypto SecureAgg 出题思路&amp;wp","text":"感觉挺神奇的，去年还是NepCTF的参赛者，今年就换成出题人的身份了。 [NepCTF2023] Crypto SecureAgg official Writeup 前段时间看了一些联邦学习安全聚合中的内容，于是就打算趁热打铁出一道相关的应用密码学题目。 考虑招新赛的难度，也不打算弄太复杂吧，对基础方案进行了一定的简化。本题考查联邦学习中最基础的安全聚合方案。当然，如果不太了解这些，也是没有关系滴，读一读代码，稍微分析一下也是完全可以做滴！ 安全聚合的目标，也就是本题的主要目标在于：给出一组用户的加密数据，如何获取原始数据的聚合结果。 题目的关键在于对每一个用户数据的加密用如下的方式： 关键就在于这里的一加一减。 我们的目的是要求，那么我们试着求一下看看会发生什么。 是用户i与j的共享密钥，那么在求和过程中对于任意两个用户，必有和相加从而抵消掉。 从而式子中只剩 最后 给出一份参考代码 123456789101112131415161718192021222324252627282930313233343536from pwn import *from Crypto.Util.number import *from hashlib import sha256from Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadfrom base64 import b64decodecontext.log_level = 'debug'#sh=remote('0.0.0.0',1337)sh=remote('nepctf.1cepeak.cn',30298)sla = lambda a,b :sh.sendlineafter(str(a),str(b))sa = lambda a,b :sh.sendafter(str(a),str(b))lg = lambda name,data : sh.success(name + \": 0x%x\" % data)se = lambda payload: sh.send(payload)rl = lambda : sh.recvline()rv = lambda n : sh.recv(n)sl = lambda payload: sh.sendline(payload)ru = lambda a :sh.recvuntil(str(a))rud = lambda a :sh.recvuntil(str(a),drop=True)ru('M=')M=int(rl().strip().decode())for i in range(20): ru('#Round %d\\n'%(i+1)) exec(rl().strip().decode()) exec(rl().strip().decode()) enc=b64decode(enc) key=(sum(enc_list)-len(enc_list)*514)*inverse(114,M)%M aes_key=sha256(str(key).encode()).digest()[:16] aes=AES.new(aes_key,AES.MODE_CBC,iv=bytes(range(16))) dec=aes.decrypt(enc) sla('message: ',unpad(dec,16).decode())sh.interactive()","link":"/202308/67f1406d.html"},{"title":"NewStarCTF Blockchain Week3 wp","text":"空闲做了做NewStarCTF，稍微看了一下blockchain题目，发现非常适合我这种入门级的新手，花时间搞搞还是能做出来的（直接秒的大佬请无视QAQ）。本来就一直想找个契机入门blockchain，现在把我的捣鼓路程做一下详细的记录。 第一个题Checkin把做题步骤写得细一点，后面的题目就不啰嗦啦。 Checkin 先nc上去看看嘞。 有四个选项。首先创建一个账户部署题目合约。 但是部署合约需要花费ether，我们需要向生成的账户中转一些ether。怎么转呢？首先你需要打开Remix，以及安装Metamask插件（具体安装使用方法可以自行搜索，网上很多）。然后打开你的Metamask，创建一个账户。 新建的账户是没有eth的（我这里已经领取并用过了）。注意，网络选择Goerli测试网络，然后去题目给出的Goerli水龙头：https://goerlifaucet.com/. 输入你的账户地址即可免费领取0.1个Goerli测试币（每24小时可领一次）。 领完之后过一小会儿刷新一下，0.1ether应该到账了。然后给题目生成的账户里转0.003个ether。 转账成功后去题目中的功能2部署合约。 得到合约地址和该交易的hash（可以去etherscan确认）。 准备工作完成，用功能4看一下合约源码。 12345678910111213141516171819202122pragma solidity 0.8.7;contract Checkin { string greeting; constructor(string memory _greeting) public { greeting = _greeting; } function greet() public view returns (string memory) { return greeting; } function setGreeting(string memory _greeting) public { greeting = _greeting; } function isSolved() public view returns (bool) { string memory key = \"HelloNewstarCTF\"; return keccak256(abi.encodePacked(key)) == keccak256(abi.encodePacked(greeting)); }} 内容很简单，我们只需要把合约中的greeting变量通过set函数更改为”HelloNewstarCTF”即可。 接下来打开Remix，根据源码创建一个合约文件并编译，然后在depoly中作以下配置： 注意environment选择Metamask，账户就会同步你的Metamask账户。然后输入题目部署好的合约地址，并点击At Address。然后在下方可以对合约的函数进行调用。 set函数是写内容，需要支付费用。我们填上所需的字符串，然后点击标签进行调用。会弹出Metamask插件进行支付，确认即可（交易明细可以根据交易哈希去etherscan查看）。 然后调用isSolved可以看到返回true了。 去功能3输入你的token即可获取flag。 guess number nc上去先拿源码： 1234567891011121314151617181920212223242526272829pragma solidity ^0.4.23;contract guessnumber { mapping(address =&gt; uint) private answer; address owner; uint number; constructor()public{ owner = msg.sender; } event isSolved(); modifier onlyOwner(){ require(msg.sender == owner); _; } function set_number(uint new_number) public onlyOwner{ number=new_number; } function guess(uint guess_number) public { answer[msg.sender]=guess_number; if(answer[msg.sender]==number){ emit isSolved(); } }} 这里set_number由于onlyOwner的修饰器，我们无法调用，只能调用guess函数。因此只能去找到number的值。 利用题目描述给出的地址去etherscan查看。点进该合约的第一条交易，进入State选项卡下。 可以看到这里一个存储值发生过变化，这里即是我们需要的number。 然后hex转一下十进制。在Remix中调用给出合约地址中的guess函数，将guess交易的hash提供到系统中即可获得flag。 the chosen one 老样子，有源码先看源码。其它的跟之前一样就不再多说了。 12345678910111213141516171819202122232425pragma solidity ^0.4.24;contract choose { address owner; event isSolved(); constructor() public{ owner = msg.sender; } function chooseone() public{ require(uint(msg.sender) &amp; 0xffff==0xabcd); owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function getflag() onlyOwner { emit isSolved(); }} 题目要求调用者地址的末位为0xabcd。我们用题目提示中给出的vanity-eth工具。 跑一会儿即可得到满足需求的地址，包括私钥。然后我们向该地址转一点ether（用于合约调用的费用），并在Metamask上登录并切换到该账户，连接上Remix。 最后先调用chooseone，再调用getflag，提交getflag的交易hash即可。","link":"/202210/295972d0.html"},{"title":"NewStarCTF Blockchain Week4 wp","text":"两道关于自毁转账和重入攻击的题目。 Demolition Trucks 题目合约源码： 1234567891011121314151617181920pragma solidity ^0.4.23;contract Trucks { constructor() public{ } event isSolved(); function getBalance() public view returns (uint256){ return address(this).balance; } function payforflag() public returns (bool){ address _to = 0x498d4BAddD959314591Dc14cb10790e8Df68b1b1; require(address(this).balance&gt;0); emit isSolved(); _to.transfer(address(this).balance); }} 题目要求合约地址的balance大于0，而我们通过题目系统创建的合约初始ether是为0的。一开始以为直接向合约里转一点ether就好，然而交易总是失败。上网查了会儿才知道合约接收转账需要payable fallback函数。题目合约里没有，这条路也就行不通了。 然后猜想题目名“自爆卡车”会不会是提示，搜了一会儿发现确实有一种自毁转账的方法。通过合约自毁强行给目标合约地址转账。 自毁方法如下： 12345678pragma solidity ^0.4.23;contract burn { function kill() public payable { selfdestruct(address(0xD2933ff4797D3e97240002F501eC2985047a9930)); }} 这里address是接收转账的目标合约地址。将以上合约进行部署，并调用kill函数。 可以看到题目合约上确实多了一点ether 然后直接调用题目合约中的payforflag即可。 baby bank 合约源码： 123456789101112131415161718192021222324252627282930313233343536373839pragma solidity ^0.4.23;contract Bank{ mapping (address =&gt; uint) public balance; event Received(address Sender, uint Value); event isSolved(); uint public chance; constructor() public { chance = 1; } function() external payable { emit Received(msg.sender, msg.value); } function gift() public { require(chance==1); balance[msg.sender] = 2; chance=0; } function withdraw(uint amount) public{ require(amount==2); require(balance[msg.sender] &gt;= amount); msg.sender.call.value(amount)(); balance[msg.sender] -= amount; } function payforflag() public { require(balance[msg.sender] &gt;= 10000000000); balance[msg.sender]=0; chance=1; emit isSolved(); address _to = 0x498d4BAddD959314591Dc14cb10790e8Df68b1b1; _to.transfer(address(this).balance); }} withdraw函数存在重入攻击漏洞。函数中先进行转账，后对变量的值进行修改。而如果转账的目标是一个合约地址，则会调用合约中的fallback函数，而攻击者则可以通过自己编写的fallback函数反复调用bank中的withdraw从而取走bank中的所有钱。 然而在本题中，我们的目标是使得调用者在bank中的balance为一个很大的值。这里可以借助withdraw函数中存在的下溢出漏洞完成。balance通过gift初始化为2，每次调用withdraw会减2，第二次调用时由于uint无符号数的特性，0-2会下溢出成一个很大的正数，从而能通过目标函数的检查。 该题操作过程如下。 首先在系统中获取目标合约（也就是被攻击的bank）地址，该合约初始是没有ether的，我们需要借助上一题里自毁的方法（操作过程见上题，不再赘述）向该合约中转一点币以保证后面转账能够顺利进行。 然后编写攻击合约： 12345678910111213141516171819202122232425262728pragma solidity ^0.4.23;import \"./Example.sol\";contract Attack{ Bank b; bool tag; constructor() public{ b=Bank(0x81d99556781BAD40ab1A56a9b84d9fE5a3a3f91A); tag=false; } function attack() public{ b.gift(); b.withdraw(2); } function getflag() public{ b.payforflag(); } function() public payable{ require(tag==false); tag=true; b.withdraw(2); }} 该合约中，攻击通过attack实施。先调用gift初始化bank中的balance为2，然后调用withdraw，在withdraw的转账过程中会默认调用攻击合约的fallback函数（也就是合约中无函数名的函数），从而再次withdraw重入。合约中使用了tag限制重入次数为2，即下溢出后就中止调用。 部署该攻击合约，调用attack，成功后可在bank中查到攻击合约的balance已经下溢出为一个很大的数了（实际上为）。 最后调用攻击合约中的getflag即可。将交易hash提交到系统中获取flag。","link":"/202210/b48e4a69.html"},{"title":"RCTF2022 Crypto部分wp","text":"不得不感慨这次RCTF Crypto的题目质量是真的高，每道题都能见到不一样的新考点，以至于做的时候翻了不少新的paper。确实也从做题过程中学到了不少东西。先写一下解出来的几道题目，剩下的下次有时间再慢慢总结复现吧。 Derek 题目关键源码： Derek.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from LFSR import LFSRfrom ctypes import c_uint64from util import aes, nsplitfrom Crypto.Util.Padding import padclass Derek(): def __init__(self, key, rnd=10): self.key = key self.rnd = rnd self.keys = list() self.generatekeys(self.key) def generatekeys(self, key: bytes) -&gt; None: lfsr = LFSR(int.from_bytes(key, 'big')) for i in range(self.rnd): b = 0 for j in range(128): b = (b &lt;&lt; 1) + lfsr.next() self.keys.append(b.to_bytes(16, 'big')) def enc_block(self, x: int) -&gt; int: x_bin = bin(x)[2:].rjust(128, '0') l, r = int(x_bin[:64], 2), int(x_bin[64:], 2) for i in range(self.rnd): magic = c_uint64(0xffffffffffffffff) for m in bytes([int(bin(byte)[2::].zfill(8)[8::-1], 2) for byte in l.to_bytes(8, 'big')]): magic.value ^= c_uint64(m &lt;&lt; 56).value for j in range(8): if magic.value &amp; 0x8000000000000000 != 0: magic.value = magic.value &lt;&lt; 1 ^ 0x1b else: magic.value = magic.value &lt;&lt; 1 magic.value ^= 0xffffffffffffffff t = bytes([int(bin(byte)[2::].zfill(8)[8::-1], 2) for byte in bytes(magic)]) t = aes(int(t.hex(), 16), self.keys[i]) &amp; 0xffffffffffffffff t ^= aes(0xdeadbeefbaadf00d if i % 2 else 0xbaadf00ddeadbeef, self.keys[i]) &amp; 0xffffffffffffffff l, r = r ^ t, l l ^= int.from_bytes(self.key[:8], 'big') r ^= int.from_bytes(self.key[8:], 'big') l, r = r, l y = (l + (r &lt;&lt; 64)) &amp; 0xffffffffffffffffffffffffffffffff return y def dec_block(self, x: int) -&gt; int: raise Exception('Unimplement') def encrypt(self, text: bytes) -&gt; bytes: text_blocks = nsplit(pad(text, 16), 16) result = b'' for block in text_blocks: block = int.from_bytes(block, 'big') result += self.enc_block(block).to_bytes(16, 'big') return result def decrypt(self, text: bytes) -&gt; bytes: raise Exception('Unimplement') LFSR.py 12345678910111213141516class LFSR(): def __init__(self, init, mask=int.from_bytes(b'RCTF2022Hack4fun', 'big'), length=128): self.init = init self.mask = mask self.lengthmask = 2**(length+1)-1 def next(self): nextdata = (self.init &lt;&lt; 1) &amp; self.lengthmask i = self.init &amp; self.mask &amp; self.lengthmask output = 0 while i != 0: output ^= (i &amp; 1) i = i &gt;&gt; 1 nextdata ^= output self.init = nextdata return output task.py 1234567891011121314151617181920212223242526272829303132import osfrom Derek import Derekwith open('flag.txt', 'rb') as f: flag = f.read()banner = '''██████╗ ███████╗██████╗ ███████╗██╗ ██╗██╔══██╗██╔════╝██╔══██╗██╔════╝██║ ██╔╝██║ ██║█████╗ ██████╔╝█████╗ █████╔╝ ██║ ██║██╔══╝ ██╔══██╗██╔══╝ ██╔═██╗ ██████╔╝███████╗██║ ██║███████╗██║ ██╗╚═════╝ ╚══════╝╚═╝ ╚═╝╚══════╝╚═╝ ╚═╝ '''print(banner)key = os.urandom(16)derek = Derek(key, rnd=42)while True: print( '| Option:\\n|\\t[E]ncrypt\\n|\\t[D]ecrypt\\n|\\t[G]et encrypted flag\\n|\\t[Q]uit') option = input('&gt; ') if option.lower() == 'e': print(derek.encrypt(bytes.fromhex( (input('msg you want to encrypt (in hex) &gt; ')))).hex()) elif option.lower() == 'd': print('unimplement') elif option.lower() == 'g': print(derek.encrypt(flag).hex()) else: exit() 一个奇怪的Feistel结构，42轮密钥加密，提供了任意加密的功能。看起来无从下手，于是结合题目名搜了一会儿，发现了Big Brother Is Watching You_ A Closer Look at Backdoor Construction，里面正好提到了Derek以及Feistel密码里存在的一种后门攻击。大致意思就是，Derek指代密码算法的设计者，在Feistel加密中故意留下一个后门用于窃取关键信息，而密码算法的使用者对此不得而知。论文里边提到了一种ZUGZWANG的Feistel网络，构造特定的输入可以使得每轮密文L部分陷入到两种不同的后门值中，一直持续到n轮结束，然后通过最后的密钥异或过程能提取出主密钥。 大致研究了一些论文里对后门的描述，发现跟本题的结构类似。0xdeadbeefbaadf00d与0xbaadf00ddeadbeef是两个后门值（对应奇偶轮数），只要让每轮中的aes加密前t等于对应的后门值，那么两次aes的异或值为0，aes起不到任何作用，t最终为0。产生的影响即是，本轮仅仅只做了一个LR交换，而每轮正好只对L进行计算，那么正好符合后门值奇偶轮数的交替，将影响一直传播到42轮结束。此时，再做一个简单的异或即可提取出主密钥key，然后用于解密。 思路就是这样，然后问题就是如何让自己的输入陷入到后门值中。在aes前面还有一块儿处理算法，也不是很难，稍微逆一下还是能写出逆算法的。然后提取出key之后，还要实现一下解密算法用于解密flag。 贴一下自己写的脚本吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from pwn import *from Crypto.Util.number import *from ctypes import c_uint64from Derek import Derekcontext.log_level = 'debug'sh=remote('94.74.90.243',42000)l64 = lambda :u64(sh.recvuntil(\"\\x7f\")[-6:].ljust(8,\"\\x00\"))l32 = lambda :u32(sh.recvuntil(\"\\xf7\")[-4:].ljust(4,\"\\x00\"))sla = lambda a,b :sh.sendlineafter(str(a),str(b))sa = lambda a,b :sh.sendafter(str(a),str(b))lg = lambda name,data : sh.success(name + \": 0x%x\" % data)se = lambda payload: sh.send(payload)rl = lambda : sh.recvline()rv = lambda n : sh.recv(n)sl = lambda payload: sh.sendline(payload)ru = lambda a :sh.recvuntil(str(a))rud = lambda a :sh.recvuntil(str(a),drop=True)def getinput(target): s=list(bytes.fromhex(target)) s[0]^=0x1b magic=int(''.join([ bin(b)[2::].zfill(8)[8::-1] for b in s][::-1]),2) magic = c_uint64(magic) magic.value ^= 0xffffffffffffffff t=magic.value ms=[] for i in range(8): tmpm='' for j in range(8): if t&amp;1: t=((t^0x1b)&gt;&gt;1)|0x8000000000000000 t=t&amp;0xffffffffffffffff tmpm+='1' else: t=t&gt;&gt;1 t=t&amp;0xffffffffffffffff tmpm+='0' tmpm=int(tmpm[::-1],2) ms.append(tmpm^0xff) ms=ms[::-1] ms=bytes([ int(bin(m)[2::].zfill(8)[8::-1], 2) for m in ms]) ms=int.from_bytes(ms,'big') return msbackdoor_l=\"baadf00ddeadbeef\"backdoor_r=\"deadbeefbaadf00d\"l=getinput(backdoor_l)r=getinput(backdoor_r)backdoor=hex((l&lt;&lt;64)+r)[2:].zfill(32)print(backdoor)#send backdoorsla('&gt; ','E')sla('&gt; ',backdoor)enc_backdoor=bytes.fromhex(rl().strip().decode())key=xor(enc_backdoor[:16],bytes.fromhex(backdoor))print(key.hex())sla('&gt; ','G')enc_flag=bytes.fromhex(rl().strip().decode())derek=Derek(key,rnd=42)flag=derek.decrypt(enc_flag)print(flag)sh.interactive()#b'RCTF{3asy_backd0or_wiTh_CRC_r3ver3s1ng}\\t\\t\\t\\t\\t\\t\\t\\t\\t' 实现的Derek的decrypt函数如下： 123456789101112131415161718192021222324252627282930313233def dec_block(self, x: int) -&gt; int: l=(x&gt;&gt;64)&amp;0xffffffffffffffff r=x&amp;0xffffffffffffffff l ^= int.from_bytes(self.key[:8], 'big') r ^= int.from_bytes(self.key[8:], 'big') for i in range(self.rnd-1,-1,-1): prev_l = r magic = c_uint64(0xffffffffffffffff) for m in bytes([int(bin(byte)[2::].zfill(8)[8::-1], 2) for byte in prev_l.to_bytes(8, 'big')]): magic.value ^= c_uint64(m &lt;&lt; 56).value for j in range(8): if magic.value &amp; 0x8000000000000000 != 0: magic.value = magic.value &lt;&lt; 1 ^ 0x1b else: magic.value = magic.value &lt;&lt; 1 magic.value ^= 0xffffffffffffffff t = bytes([int(bin(byte)[2::].zfill(8)[8::-1], 2) for byte in bytes(magic)]) t = aes(int(t.hex(), 16), self.keys[i]) &amp; 0xffffffffffffffff t ^= aes(0xdeadbeefbaadf00d if i % 2 else 0xbaadf00ddeadbeef, self.keys[i]) &amp; 0xffffffffffffffff prev_r = l^t l, r = prev_l, prev_r return ((l&lt;&lt;64)+r) &amp; 0xffffffffffffffffffffffffffffffffdef decrypt(self, text: bytes) -&gt; bytes: text_blocks = nsplit(text, 16) result = b'' for block in text_blocks: block = int.from_bytes(block, 'big') result += self.dec_block(block).to_bytes(16, 'big') return result Clearlove 题目源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from Crypto.Util.number import *with open('flag.txt', 'rb') as f: msg = f.read()junk_msg = [os.urandom(120) for i in range(65536)]for i in range(len(msg)): junk_msg[i] = junk_msg[i][:i] + bytes([msg[i]]) + junk_msg[i][i+1:]p = 990367536408524906540912485167816012092796554403092639917950993714265910699138052663068131070259292593771612112016905904144038137551264432483487958987773403759866096258076571660618998739176702013853258687325567753038298889168254166361474202422033630403618955865472205722190830457928271527937g = 745013838642250986737914025336862504661062017981819269513542907265222774830330586097756124678061002877695509685688964126565784246358161149675046363463274308162223776270434432888284419417479549219965033745142547821863438374478028783067286583042510995247992045551680383288951502770625897136683Zp = Zmod(p)g = Zp(g)junk_msg = [Zp(bytes_to_long(msg)) for msg in junk_msg] junk_cipher = []for i in range(65536): junk_cipher.append(ZZ(sum(junk_msg[j] * g^(i*j) for j in range(65536))))def generate_params(beta): n = 1024 delta = 0.642 p_upper_bound = 1 &lt;&lt; (n // 2) p_lower_bound = p_upper_bound &gt;&gt; 1 p = random_prime(p_upper_bound, lbound=p_lower_bound) pqdiff_upper_bound = 1 &lt;&lt; int(n * beta) ''' Jinx: QUADRA KILL ''' pqdiff_lower_bound = pqdiff_upper_bound * 0.7777777 q = next_prime(p + random_prime(pqdiff_upper_bound, lbound=pqdiff_lower_bound)) N = p * q AAHPH = (p^2 - 1) * (q^2 - 1) d_upper_bound = 1 &lt;&lt; (int(n * delta)) d_lower_bound = d_upper_bound &gt;&gt; 1 while True: d = random_prime(d_upper_bound, lbound=d_lower_bound) if gcd(d, AAHPH) == 1: e = inverse_mod(d, AAHPH) if gcd(e, AAHPH) == 1: break return (N, e), (N, e, d, p, q)'''EDG.Clearlove'''beta = 0.4396pk, sk = generate_params(beta)N, e, d, p, q = skprint('PLEASE WAIT...')ZN = Zmod(N)garbage_cipher = [ZN(jc) ^ e for jc in junk_cipher]N, e = pktroll = list(map(str, garbage_cipher)) + ['-' * 77, f'{N = }', f'{e = }']e, d, g = 'Clearlove', 'LeeSin', '4396'EDG = '\\n'.join(troll)with open('output.txt', 'w') as f: f.write(EDG) 首先肯定是要分解N的，然后观察参数的生成过程，发现定义了一个pq差值的界，那么大概率是以此为突破口。于是去找相关的论文，找到了Cryptanalysis of RSA Variants with Primes Sharing Most Significant Bits这篇论文，正好针对本题这种RSA变体。论文针对小|p-q|提出了一种连分数方法和CopperSmith方法，其临界条件分别为和。后者临界是比前者要大的，而本题数据只能满足后者，因此考虑采用CopperSmith攻击。 首先考虑如下关系： 定义，然后引入新的变量以降低xy项的指数，即。 然后与其它类似基于CopperSmith的攻击类似，构造多项式： 其中m和t是与参数有关的常量。然后对H中的多项式中包含的xy用u-1替换，并以某种偏序对单项式排列（实际上在生成G, H的过程中已经排好了）。再将上界代入单项式中得到矩阵L，对该矩阵构成的格进行LLL规约，可以重构出一些短向量构成的多项式，它们有公共根, 通过groebner基或者消元方法可以解得，进而与结合分解。 一些细节感兴趣可以具体去查看论文。 然后本题我在实际运行时发现m设置太小时分解不出来，自己测试了m=7时大概能分解delta=0.62左右的数据，delta再高一点就不行了。遂直接设置m=10，格规约等计算也是很耗时，跑了很久才跑出来。 分解N这一块儿的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192lines=open('output3.txt','r').readlines()cs=[ int(lines[i].strip()) for i in range(65536)]exec(lines[65537].strip())exec(lines[65538].strip())delta=0.642beta=0.4396alpha=int(e).bit_length()/int(N).bit_length()assert (delta &lt; (2-sqrt(2*alpha*beta)))P.&lt;x, y, u&gt; = PolynomialRing(ZZ)X = 2 * ceil(N ^ (alpha + delta - 2))Y = ceil(N ^ (2 * beta))U = 2 * ceil(N ^ (alpha + delta + 2 * beta - 2))tau = (2 - delta - 2 * beta) / (2 * beta)m = 10t = ceil(tau * m)A = - ( (N - 1) ^ 2)f = u + A * xdef replace_func(f): res=0 for coe,exp in zip(f.coefficients(),f.exponents()): mi=min(exp[0],exp[1]) tmp=coe * (u-1)^mi * x^(exp[0]-mi) * y^(exp[1]-mi) * u^exp[2] res+=tmp return respolys=[]for k in range(m + 1): for i in range(m - k + 1): g = x^i * f^k * e^(m-k) polys.append(g)for i in range(1, t + 1): for k in range(floor(m/t) * i, m + 1): h = y^i * f^k * e^(m-k) polys.append(replace_func(h))print(len(polys))monomials=[]for poly in polys: for v in poly.monomials(): if v not in monomials: monomials.append(v)mat = [[0 for j in range(len(monomials))] for i in range(len(polys))]print(monomials)for i, poly in enumerate(polys): for j, mono in enumerate(monomials): mat[i][j] = poly.monomial_coefficient(mono)*mono(X,Y,U)#print(mat)mat = Matrix(ZZ, mat)mat = mat.LLL()#open('mat2.txt','w').write(str(list(mat)))#mat=eval(open('mat.txt','r').read())print('LLL done!')pols = []for i in range(len(polys)): f = sum(mat[i][k] / monomials[k](X, Y, U) * monomials[k] for k in range(len(monomials))) pols.append(f)print(len(pols))pols = [u-x*y-1]+pols#for i in range(len(pols)-1,3,-1):for i in range(80,3,-1): print(i) try: v=Ideal(pols[:i]).variety(ring=ZZ) if len(v)&gt;0: print(v) y=int(v[0]['y']) pmq=sqrt(y) print(pmq) P.&lt;p&gt;=PolynomialRing(ZZ) f=p^2+p*pmq-N print(f.roots()) except Exception as e: print(e) pass'''[{u: -1695166360783623077154052389508246716761861722024404817214394600789803790403714200440369940787684400663494200881068944398548897575845907495606656469179282707827170529419212760406144142733347243197128881554680855071165806986096732724661579030640404199847619606235708970363609649328202045644653634610040799601597995193052707889314808055275816604399932498458439501479692477453686448515572462746542145553884637351688240966459098085476680544150909930373794916747700646448303, y: 7893799151870106368997715597004629614318877379147732503688536007499549221939769093779781858805544426360289846440239798972043620324852053072235936828334755393166491885822031250207242929799675100359166402558473234456030844109650292442936161876265905285215187501954746170896, x: -214746578696776713987299905475467568414024070212204855203647033887737055875538527514031663379363545097645608173370365619963730797249459248088432091685347829523013133246951132387167391403870749702699}][(-10145464108117104949338515959842773933364500202544475266126577386047458426369581988106804702576518219589482814270717140789491480763576506436948323698765533, 1), (10145464108117104946528925393253025011804035401616805446033365549148734952013370668386041469047007957274792466373040522919369708124243037663040944850113697, 1)]''' N分解之后，对garbage_cipher解RSA可以得到junk_cipher向量。该向量的构成形式如下： 然而这里n=65536，中间这个矩阵实在太大，根本就构建不出来，更别说求解了。然后我当时思路就断这儿了。后幸得队内高人指点，看到一篇博客，这才发现原来这就是个范德蒙方阵。而对于由1的n次根w构成的范德蒙方阵，其求逆也有简便的方法： 题目里是模域，而我们惊奇地发现给出的数据正好满足，那么可以直接用以上的逆矩阵求法。由于flag只在junk_message向量的前几十个元素中，我们无需求出整个逆矩阵去与junk_cipher向量相乘，只需要算前几十行即可，这样就在可以接受的时空复杂度范围内了。 后面这一块儿的解题过程如下： 123456789101112131415161718192021222324252627282930313233from Crypto.Util.number import *from tqdm import tqdmlines=open('output3.txt','r').readlines()cs=[ int(lines[i].strip()) for i in range(65536)]exec(lines[65537].strip())exec(lines[65538].strip())P=10145464108117104946528925393253025011804035401616805446033365549148734952013370668386041469047007957274792466373040522919369708124243037663040944850113697Q=N//Pd=inverse(e,(P-1)*(Q-1))ZN=Zmod(N)n=65536jc=[pow(c,d,N) for c in cs[:n]]#open('jc.txt','w').write(str(jc))#jc=eval(open('jc.txt','r').read())print('-----')p = 990367536408524906540912485167816012092796554403092639917950993714265910699138052663068131070259292593771612112016905904144038137551264432483487958987773403759866096258076571660618998739176702013853258687325567753038298889168254166361474202422033630403618955865472205722190830457928271527937g = 745013838642250986737914025336862504661062017981819269513542907265222774830330586097756124678061002877695509685688964126565784246358161149675046363463274308162223776270434432888284419417479549219965033745142547821863438374478028783067286583042510995247992045551680383288951502770625897136683Zp = Zmod(p)g = Zp(g)flag=b''jc=vector(Zp,jc)for i in range(100): print(i) v=Zp(n)^-1*vector(Zp,[ g^-(i*j) for j in range(n)]) jm=long_to_bytes(int(v*jc)) flag+=bytes([jm[i]]) print(flag)print(flag)#RCTF{G00d_J06_UR_cRypT0_ma5T3r__1997_L0VE_ZMJ_FOR3VER} easyRSA 题目源码： 1234567891011121314151617181920212223242526272829from Crypto.Util.number import getPrime, inverse, bytes_to_longwith open('flag.txt', 'rb') as f: flag = f.read()def v(k): if k == 0: return 2 if k == 1: return r return (r * v(k - 1) - v(k - 2)) % (N * N)def encrypt(m, e, N): c = (1 + m * N) * v(e) % (N * N) return cp = getPrime(512)q = getPrime(512)N = p * qd = getPrime(512)r = getPrime(512)e = inverse(d, (p * p - 1) * (q * q - 1))c = encrypt(bytes_to_long(flag), e, N)print(f\"e = {e}\")print(f\"c = {c}\")print(f\"N = {N}\") 参考论文Cryptanalysis of RSA-type cryptosystems based on Lucas sequences, Gaussian integers and elliptic curves. 论文4节中提到一种针对形式的连分数攻击，需要满足条件为： 代入题目数据计算发现右边为513bits，而d为512bits。因此对,连分数展开可以找到一个近似逼近等于。然后，与N=pq结合可以求出p和q。 然后题中的加密方式其实是基于Lucas序列的一种RSA变体。在拿到分解出的p和q之后，可以很轻松地利用该论文中2.3节的解密方法进行解密。求v的时候可以把迭代递归转化成矩阵相乘。 连分数分解： 1234567891011121314151617181920212223242526from Crypto.Util.number import *from gmpy2 import irootfrom tqdm import tqdme = 3121363059746835628022404544403822724460605553641332612055010587129451973002475126644668174294955070747985002800863652917895939538596303356113483509581841527286351537287500304267975061675901109982875778527827742120878835367386538561039072391997357702421691095861694681707017921391244519593945584755632901987840338065879901115934561426583008838453244051629340056867760923894623105542463500022221236457852502822707466528439969484890601953615303609725566617126458934095119670087068752543521167517461730977044465374505011791902510131823556603316457085145886999220426746234986984619161299098173535371540923264898459106461c = 3023313363629909506923927199426293187583112749147539699346723655095868214179291222441307436555352537055690155418715652987685459938250844145450675418187664719327350488160722838989675928696633353180233455017609936874014883975932740217672705286265535646106053294507962613498142617741362730709360885118905440314573392981528077265110441270212385951070591696827167771592664502652520790612367259434545169836933571343480057141790292296952743986731389468760364416344837575740236416472589700581583016227273449673820568427641136163703116276104550877191839851640920430919278802098196408637904780725723268371465670950321881886863N = 101946888552605033726177837709738163930032970477361664394564134626639467843553634920510447339985842689387519517553714582991506722045078696771986052246306068257957261478416093188640437503481862825381241480405463985516598520453211217206308826779669980833596066677262549841524134539729279446910817169620871929289bound=int(sqrt((2*N^3-18*N^2)//e))print(bound.bit_length())c = continued_fraction(e/(N^2 - 9*N//4 + 1))p,q = var('p q')f1 = p * q - Nfor i in tqdm(range(2,len(c))): k = c.numerator(i) d = c.denominator(i) w = (e * d - 1) // k if (N+1)^2 - w + 1 &lt; 0: continue if iroot((N+1)^2 - w ,2)[1]: print(int(d).bit_length()) W = int(iroot((N+1)^2 - w ,2)[0]) f2 = p + q - W print(solve([f1,f2],[p,q])) break Lucas解密： 1234567891011121314151617181920212223242526272829303132333435363738from Crypto.Util.number import *p = 11183005686209595001928972121695860070092013480977374483129957127854844677143979460482157275466240702921372008061294251388860670887956597721784208073814949q = 9116233275131173602739752692268079943189703035300573582575042083296621527313939933344455320687281588438414528000594454794847729159565419506066306192152661e = 3121363059746835628022404544403822724460605553641332612055010587129451973002475126644668174294955070747985002800863652917895939538596303356113483509581841527286351537287500304267975061675901109982875778527827742120878835367386538561039072391997357702421691095861694681707017921391244519593945584755632901987840338065879901115934561426583008838453244051629340056867760923894623105542463500022221236457852502822707466528439969484890601953615303609725566617126458934095119670087068752543521167517461730977044465374505011791902510131823556603316457085145886999220426746234986984619161299098173535371540923264898459106461c = 3023313363629909506923927199426293187583112749147539699346723655095868214179291222441307436555352537055690155418715652987685459938250844145450675418187664719327350488160722838989675928696633353180233455017609936874014883975932740217672705286265535646106053294507962613498142617741362730709360885118905440314573392981528077265110441270212385951070591696827167771592664502652520790612367259434545169836933571343480057141790292296952743986731389468760364416344837575740236416472589700581583016227273449673820568427641136163703116276104550877191839851640920430919278802098196408637904780725723268371465670950321881886863N = 101946888552605033726177837709738163930032970477361664394564134626639467843553634920510447339985842689387519517553714582991506722045078696771986052246306068257957261478416093188640437503481862825381241480405463985516598520453211217206308826779669980833596066677262549841524134539729279446910817169620871929289d = int(inverse(e,(p**2-1)*(q**2-1)))def seq(r , k , n): init_v = vector(Zmod(n) , [2 , r]) M = Matrix(Zmod(n) , [ [0 , -1], [1 , r ] ]) ret = ( init_v * M^(k-1))[1] return retinvp=inverse(p,q)invq=inverse(q,p)ip=legendre_symbol(c^2-4,p)dpip=inverse(int(e),p-ip)iq=legendre_symbol(c^2-4,q)dqiq=inverse(int(e),q-iq)rp=int(seq(c%p,dpip,p))rq=int(seq(c%q,dqiq,q))r=(rp+p*(rp-rq)*invp)%Nvp=int(seq(r,e,p^2))vq=int(seq(r,e,q^2))tp=c*inverse(vp,p^2)%p^2mp=((tp-1)//p)*invq%ptq=c*inverse(vq,q^2)%q^2mq=((tq-1)//q)*invp%qm=(mp+p*(mq-mp)*invp)%Nprint(long_to_bytes(m))b'RCTF{eAsy_1uca5_se9uEnce_a6ea27d4177d}' Guess 题目源码： 123456789101112131415161718192021222324252627282930313233from Crypto.Util.number import getPrime, bytes_to_longfrom random import randint, choicesfrom string import ascii_uppercase, digitsimport signalwith open('flag.txt', 'rb') as f: flag = f.read()signal.alarm(300)q = getPrime(160)while True: key = \"rctf_\" + \"\".join(choices(ascii_uppercase + digits, k=15)) x = bytes_to_long(\"\".join(sorted(key)).encode()) if x &lt; q: breakl = 2T = []U = []for i in range(90): t = randint(1, q) #u = (x * t - randint(1, q &gt;&gt; l)) % q u = x * t - randint(1, q &gt;&gt; l) T.append(t) U.append(u)print(f\"q = {q}\")print(f\"T = {T}\")print(f\"U = {U}\")guess = int(input(\"x = \").strip())if guess == x: print(flag) 随机值影响很小，u//t可以得到x的近似值，测试一下然后发现直接发送u//t+1就行。 解题代码： 123456789101112131415161718192021222324252627282930from pwn import *import reimport stringfrom Crypto.Util.number import *#context.log_level = 'debug'sh=remote('190.92.234.114',23334)l64 = lambda :u64(sh.recvuntil(\"\\x7f\")[-6:].ljust(8,\"\\x00\"))l32 = lambda :u32(sh.recvuntil(\"\\xf7\")[-4:].ljust(4,\"\\x00\"))sla = lambda a,b :sh.sendlineafter(str(a),str(b))sa = lambda a,b :sh.sendafter(str(a),str(b))lg = lambda name,data : sh.success(name + \": 0x%x\" % data)se = lambda payload: sh.send(payload)rl = lambda : sh.recvline()rv = lambda n : sh.recv(n)sl = lambda payload: sh.sendline(payload)ru = lambda a :sh.recvuntil(str(a))rud = lambda a :sh.recvuntil(str(a),drop=True)for _ in range(3): exec(rl().decode().strip())arr=[u//t for u,t in zip(U,T)]print(long_to_bytes(arr[0]))#b'269FFIIIKMPQRSS_cfrs'sla('x = ',str(arr[0]+1))sh.interactive()#RCTF{h0p3_this_gUes5_cHal1eNge_is_N0T_gue5sY}","link":"/202212/4446a1ac.html"},{"title":"RSA parity oracle例题复现","text":"最近在比赛中碰到了RSA parity oracle攻击的题目，当时对这个攻击没有什么印象，赛后看wp复现了一遍，这里稍微总结一下。 [CTFshow七夕杯] 优势在我 题目源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from Crypto.Util.number import *import hashlibimport sysfrom private import ddef pr(x, end=\"\\n\"): sys.stdout.write(str(x)+end) sys.stdout.flush()BANNER = \"\"\"...\"\"\"N = 18546721845979927569500143751660105533561486316231224465080625317376238264944740878457193385226698959802719372533690834284860737851929107163579187879895388120942312652954549671398264315985738386063687826049340153475764762320419809887400141782272319772175613926330746384510813184415900331770119033044622690940477810277396517358312757248120240055407842257982535105406966617903737782220404404644459553334905091694987679788339901767262741660223359618116200505397580036748964773373441655648565481823043475551779287949673519191553190302422175246969165641890331993628578551062334369824625164536808726394693221961254696074691e = 65537p = 24074624372939710957902553829568388349796810585932597965247721110129830468800036256026076982213498961372616008101708874099574700088150475222639563817914865052788850184089778132465415340980378135746900061263517304153485433985299953682148733981366808528082636204740025363446729188464380931250501761664305346381138286856186476986484913576109916879190154878781616175599052154216615394032414499234529973797040464698872321982946683153298157064531262284470661150270186224788419122959403896437988552792877168892664837002108590144855389176310488655364026719942320436915792611600545729690463037233338070404315644982404557646573g = 2with open(\"flag.txt\", \"rb\") as f: flag = f.read()flag = bytes_to_long(flag)assert flag &lt; Ndef strange_tales(x): msg1 = b\"Never gonna make you cry\" + x msg2 = b\"Never gonna say goodbye\" + x return bytes_to_long(hashlib.sha512(msg1).digest() + hashlib.sha512(msg2).digest())def full_of_foolish_talk(x): k = getRandomRange(0, p - 1) r = pow(g, k, p) e = strange_tales(str(r).encode() + b\"Never gonna tell a lie and hurt you\") s = (k - x * e) % (p - 1) return r, spr(BANNER)pr(f\"We're no strangers to love: {pow(flag, e, N)}\")pr(\"You know the rules and SO DO I\")while True: pr(\"&gt; \", end=\"\") c = int(input()) m = pow(c, d, N) r, s = full_of_foolish_talk(m) pr(f\"Never gonna give you up: {r}\") pr(f\"Never gonna let you down: {s}\") 乍一看r和s，以为是一道DSA，其实半毛钱关系没有。题目中能对任意密文解密，并输出解密后明文m对应的r和s，其中有动态随机数k参与运算，我们很难构造r，s和m之间的关系来反推出m，正向分解N来破解RSA也不可能。 这里就是本题关键所在了，我们需要通过r和s来分析得到对应m的奇偶性，然后运用RSA parity oracle的思想来求出m。首先简单说一下RSA parity oracle攻击的思路。这一攻击的前提是需要能够进行任意密文的解密，并能得到解密明文的奇偶性，即对于任意c，能够知道的奇偶性，这样即可恢复所求明文。具体分析如下： 对于所求明文m，我们可以构造c来求出的奇偶性。然后由于2m为偶数，N为奇数，且有,若为奇数，则说明,即有;反之则有.这样我们就可以得到m的一个二分取值区间。然后我们继续迭代这样的构造，最终二分区间缩小为一个值时，该值即为最终的明文m。对于RSA而言，即是构造 继续说回此题，我们的目的即是通过r和s找出m的奇偶性。首先根据可以看到，p-1是偶数，那么s和k-x*e的奇偶性一致。这里k满足,k的奇偶性可以由r关于p的勒让德符号求出（因为k为偶数时，r必定是一个二次剩余），因此可以算出x*e的奇偶性。如果此时e也为奇数，那么也就可以得到x的奇偶性了。由于e是r的哈希，我们可以多次尝试，得到一个我们想要的奇数e，以算出当前m的奇偶性，进而用RSA parity oracle逐步二分得到flag。 解题脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import randomfrom pwn import *from Crypto.Util.number import *import gmpy2import hashlibsh = remote('pwn.challenge.ctf.show',28027)context.log_level='debug'l64 = lambda :u64(sh.recvuntil(\"\\x7f\")[-6:].ljust(8,\"\\x00\"))l32 = lambda :u32(sh.recvuntil(\"\\xf7\")[-4:].ljust(4,\"\\x00\"))sla = lambda a,b :sh.sendlineafter(str(a),str(b))sa = lambda a,b :sh.sendafter(str(a),str(b))lg = lambda name,data : sh.success(name + \": 0x%x\" % data)se = lambda payload: sh.send(payload)rl = lambda : sh.recvline()rv = lambda n : sh.recv(n)sl = lambda payload: sh.sendline(payload)ru = lambda a :sh.recvuntil(str(a))rud = lambda a :sh.recvuntil(str(a),drop=True)N = 18546721845979927569500143751660105533561486316231224465080625317376238264944740878457193385226698959802719372533690834284860737851929107163579187879895388120942312652954549671398264315985738386063687826049340153475764762320419809887400141782272319772175613926330746384510813184415900331770119033044622690940477810277396517358312757248120240055407842257982535105406966617903737782220404404644459553334905091694987679788339901767262741660223359618116200505397580036748964773373441655648565481823043475551779287949673519191553190302422175246969165641890331993628578551062334369824625164536808726394693221961254696074691E = 65537p = 24074624372939710957902553829568388349796810585932597965247721110129830468800036256026076982213498961372616008101708874099574700088150475222639563817914865052788850184089778132465415340980378135746900061263517304153485433985299953682148733981366808528082636204740025363446729188464380931250501761664305346381138286856186476986484913576109916879190154878781616175599052154216615394032414499234529973797040464698872321982946683153298157064531262284470661150270186224788419122959403896437988552792877168892664837002108590144855389176310488655364026719942320436915792611600545729690463037233338070404315644982404557646573g = 2def interact(c): sla('&gt; ',str(c)) ru('Never gonna give you up: ') r=int(rl()) ru('Never gonna let you down: ') s=int(rl()) return r,sdef H(r): x=str(r).encode() + b\"Never gonna tell a lie and hurt you\" msg1 = b\"Never gonna make you cry\" + x msg2 = b\"Never gonna say goodbye\" + x return bytes_to_long(hashlib.sha512(msg1).digest() + hashlib.sha512(msg2).digest())def get_parity(r,s): e=H(r) if e%2: sp=s%2 kp=1 if gmpy2.legendre(r,p)==-1 else 0 xp=sp^kp return xp else: return Noneru(\"We're no strangers to love: \")encflag=int(rl())lb,ub,c=[0,N,pow(2,E,N)*encflag%N]cnt=0while True: r,s=interact(c) parity=get_parity(r,s) if parity is None: continue if parity==1: lb=(lb+ub)//2 else: ub=(lb+ub)//2 c=pow(2,E,N)*c%N cnt+=1 if lb==ub: print(cnt) print(long_to_bytes(lb)) exit(0)p.interactive() 这里直接用gmpy里的legendre，sage里的legendre_symbol跑起来有点慢。 总结一下RSA parity oracle攻击的条件就是：需要能够任意密文的解密，并能得到明文的奇偶性。满足这一条件就可以考虑采用这种思想了。 在corctf貌似看到了该手法的变种，等赛后有了wp再来复现一波~ 补充复现： [corCTF 2022] generous 题目源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/local/bin/pythonfrom Crypto.Util.number import getPrime, inverse, bytes_to_longfrom random import randrangewith open(\"flag.txt\", \"rb\") as f: flag = f.read().strip()def gen_keypair(): p, q = getPrime(512), getPrime(512) n = (p**2) * q while True: g = randrange(2, n) if pow(g, p-1, p**2) != 1: break h = pow(g, n, n) return (n, g, h), (g, p, q)def encrypt(pubkey, m): n, g, h = pubkey r = randrange(1, n) c = pow(g, m, n) * pow(h, r, n) % n return cdef decrypt(privkey, c): g, p, q = privkey a = (pow(c, p-1, p**2) - 1) // p b = (pow(g, p-1, p**2) - 1) // p m = a * inverse(b, p) % p return mdef oracle(privkey, c): m = decrypt(privkey, c) return m % 2pub, priv = gen_keypair()n, g, h = pubprint(f\"Public Key:\\n{n = }\\n{g = }\\n{h = }\")print(f\"Encrypted Flag: {encrypt(pub, bytes_to_long(flag))}\")while True: inp = int(input(\"Enter ciphertext&gt; \")) print(f\"Oracle result: {oracle(priv, inp)}\") 这题仍然是有一个明显的parity oracle，只不过加密系统不再是RSA。注意到这里公钥加密是模n的，而私钥解密出的m则是模p的。由于p是未知的，因此我们无法像之前一样设置上下界来准确地二分求出m。但是，此题我们可以换一个思路，利用parity oracle去求p。原理同前一题类似： 我们知道p是小于的，因此我们可以构造，然后利用parity oracle得到的奇偶性，若为奇数，则说明m大于p；否则，m小于p。接着，我们继续二分缩小p的范围，最终能够求出p。 求出p之后就能算出私钥，然后直接解密即可。 解题脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from random import randrangefrom pwn import *from Crypto.Util.number import *import gmpy2import hashlibsh = remote('be.ax',31244)#context.log_level='debug'l64 = lambda :u64(sh.recvuntil(\"\\x7f\")[-6:].ljust(8,\"\\x00\"))l32 = lambda :u32(sh.recvuntil(\"\\xf7\")[-4:].ljust(4,\"\\x00\"))sla = lambda a,b :sh.sendlineafter(str(a),str(b))sa = lambda a,b :sh.sendafter(str(a),str(b))lg = lambda name,data : sh.success(name + \": 0x%x\" % data)se = lambda payload: sh.send(payload)rl = lambda : sh.recvline()rv = lambda n : sh.recv(n)sl = lambda payload: sh.sendline(payload)ru = lambda a :sh.recvuntil(str(a))rud = lambda a :sh.recvuntil(str(a),drop=True)def get_parity(c): sla('ciphertext&gt; ',str(c)) ru('Oracle result: ') parity=int(rl()) return paritydef encrypt(pubkey, m): n, g, h = pubkey r = randrange(1, n) c = pow(g, m, n) * pow(h, r, n) % n return cdef decrypt(privkey, c): g, p, q = privkey a = (pow(c, p-1, p**2) - 1) // p b = (pow(g, p-1, p**2) - 1) // p m = a * inverse(b, p) % p return mru('n = ')n=int(rl().strip())ru('g = ')g=int(rl().strip())ru('h = ')h=int(rl().strip())ru(\"Encrypted Flag: \")encflag=int(rl())lb,ub=[0,2**512]cnt=0while True: tmpm=(lb+ub)//2 c=encrypt((n,g,h),tmpm) parity=get_parity(c) if parity==1: ub=tmpm else: lb=tmpm cnt+=1 print(lb,ub) if ub-lb&lt;=1: print(cnt) p=lb assert isPrime(p) q=n//(p**2) flag=decrypt((g,p,q),encflag) print(long_to_bytes(flag)) exit(0)p.interactive()","link":"/202208/1880d078.html"},{"title":"WMCTF2022 Crypto wp","text":"两天的WMCTF，整个做下来感觉密码题出得确实蛮好的，很值得学习与复现。在比赛中也能收获很多知识。很棒！明年还来~ 先记录一下解出的题目。ocb磕了一下午没磕出来，就等wp吧（应该会有吧~）。 ecc 题目没有给源码，只给了输出文本： 1234567flag bits: 606e = 0x10001n = 61262574892917665379101848600282751252633178779864648655116434051615964747592676204833262666589440081296571836666022795166255640192795587508845265816642144669301520989571990670507103278098950563219296310830719975959589061794360407053224254135937766317251283933110936269282950512402428088733821277056712795259c = 16002162436420434728223131316901476099110904029045408221515087977802746863468505266500673611412375885221860212238712311981079623398373906773247773552766200431323537510699147642358473715224124662007742017000810447999989426207919068340364725395075614636875116086496704959130761547095168937180751237132642548997G = (3364552845709696244757995625685399274809023621531082895612949981433844727622567352338990765970534554565693355095508508160162961299445890209860508127449468 : 4874111773041360858453223185020051270111929505293131058858547656851279111764112235653823943997681930204977283843433850957234770591933663960666437259499093 : 1)3G = (8240596254289477251157504980772167439041663401504657696787046343848644902166655624353107697436635678388969190302189718026343959470011854412337179727187240 : 4413479999185843948404442728411950785256136111461847698098967018173326770728464491960875264034301169184074110521039566669441716138955932362724194843596479 : 1) 根据常识可以知道，这里包含了RSA参数和ECC上和两个点。这套路岂不是和前段时间的corCTF-threetreasures很相似，RSA和ECC共用同一个因子。猜测本题也是把flag分成三块。因此需要根据ECC上两个点的信息求出ECC的参数，然后分解来解RSA。 我们有ECC上两个点的坐标，因此根据ECC方程可以得到两个方程来求出和。由于这里与threetreasures题目有一定区别，无法针对的高位使用coppersmith攻击，但是我们还可以利用和两个点之间的关系。 具体来讲，我们先用两个点的坐标得到两个多项式，然后可以先在模的意义下求出和，然后利用ECC点乘计算公式得到两点坐标之间的关系，而给的坐标是模意义下的，从而可以与做gcd从而分解出。然后常规解RSA，同时求出和模的值即可。 解题脚本: 1234567891011121314151617181920212223242526272829303132from Crypto.Util.number import *from sage.matrix.matrix2 import Matrixflag_bits=606e = 0x10001n = 61262574892917665379101848600282751252633178779864648655116434051615964747592676204833262666589440081296571836666022795166255640192795587508845265816642144669301520989571990670507103278098950563219296310830719975959589061794360407053224254135937766317251283933110936269282950512402428088733821277056712795259c = 16002162436420434728223131316901476099110904029045408221515087977802746863468505266500673611412375885221860212238712311981079623398373906773247773552766200431323537510699147642358473715224124662007742017000810447999989426207919068340364725395075614636875116086496704959130761547095168937180751237132642548997Gx,Gy = (3364552845709696244757995625685399274809023621531082895612949981433844727622567352338990765970534554565693355095508508160162961299445890209860508127449468 , 4874111773041360858453223185020051270111929505293131058858547656851279111764112235653823943997681930204977283843433850957234770591933663960666437259499093 )G3x,G3y = (8240596254289477251157504980772167439041663401504657696787046343848644902166655624353107697436635678388969190302189718026343959470011854412337179727187240 , 4413479999185843948404442728411950785256136111461847698098967018173326770728464491960875264034301169184074110521039566669441716138955932362724194843596479 )R.&lt;a,b&gt;=PolynomialRing(Zmod(n))I=[]I.append(Gx^3+a*Gx+b-Gy^2)I.append(G3x^3+a*G3x+b-G3y^2)res=Ideal(I).groebner_basis()a=int(-res[0].constant_coefficient())b=int(-res[1].constant_coefficient())lam1=(3*Gx^2+a)*pow(2*Gy,-1,n)G2x=lam1^2-2*GxG2y=lam1*(Gx-G2x)-Gylam2=(G2y-Gy)*pow(G2x-Gx,-1,n)G3x_=lam2^2-G2x-Gxp=int(gcd(G3x_-G3x,n))assert isPrime(p)q=n//pd=inverse(e,(p-1)*(q-1))m=int(pow(c,d,n))a=a%pb=b%pflag=(a&lt;&lt;404)+(b&lt;&lt;202)+mprint(long_to_bytes(flag))#$$U_c0u1d_s01v3_e11iptiCurv3_s0_34sily$$0f19d82199a0db0dee31fa12330307ea90aa homo 题目源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from Crypto.Util.number import * from secret import flagfrom random import *assert flag.startswith(b'wmctf{') and flag.endswith(b'}')flaglen = len(flag) - 7flag = bytes_to_long(flag[6:-1])pbit = 114qbit = 514rbit = 191keylen = 981nouse = 0def keygen(): pk = [] sk = getPrime(qbit) for i in range(keylen): print(i) p = getPrime(pbit) r = getPrime(rbit) pk.append(p*sk + 2*r) return pk , skdef enc(m , pk): c = [] m = [int(i) for i in bin(m)[2:]] print(m) for i in m: tempc = i for j in range(keylen): if randint(0 , 1): tempc += pk[j] c.append(tempc) return cpk , sk = keygen()print(sk)c = enc(flag , pk)f = open('./pubkey.txt' , 'w')f.write(str(pk))f.close()f = open('./cipher.txt' , 'w')f.write(str(c))f.close()print([(i%sk)%2 for i in c])print(sk) 怎么哪里都有homo啊！（恼） 还有你这个参数是怎么回事啊喂！ 说正经的，本题的homo应该指的是同态加密（Homomorphic Encryption, HE），而本题也正是整数上基于近似最大公因子（Approximate-GCD, AGCD）的全同态加密方案（Fully Homomorphic Encryption, FHE）。而该加密方案早在2012年被Gu Chunsheng指出存在一种启发式攻击方法，能够借助格基规约算法，能在多项式时间内无需恢复secret key（即本题中的）而直接还原明文。详情可具体参考论文，论文链接在此。 论文攻击的大致思想是，添加一种小的噪声项来消除部分的影响，从而根据奇偶性直接判断明文的比特位。整个过程可以巧妙利用公钥根据参数设置来构造格，并对规约出的最短基向量进行判断来完成。 好吧，其实原理也只是略懂一点，但是做题已经够了。根据该攻击方案可以写出对应的脚本： 12345678910111213141516171819202122from Crypto.Util.number import *cipher=eval(open('cipher.txt','r').read())pubkey=eval(open('pubkey.txt','r').read())l=28res=''for c in cipher: M=Matrix(ZZ,1+l,2+l) col0=vector([c]+pubkey[1:l]+[pubkey[0]]) M.set_column(0,col0) for i in range(1+l): M[i,i+1]=1 ML=M.LLL() c1=[ i%2 for i in ML.column(0)] c2=[ i%2 for i in ML.column(1)] if c1[:-1]==c2[:-1]: res+='1' else: res+='0'flag=long_to_bytes(int(res,2))print(flag)#sodayo&gt;A&lt;!!$%!$_Easy_G@CDp_ATtaCk nanoDiamond &amp; nanoDiamond-rev nanoDiamond-rev没搞出来，呜呜还是太菜了，这里先蹲一手大佬们的wp，到时复现一下。 nanoDiamond就先不码了，毕竟能打通后者肯定能打通前者。 INTERCEPT 题目源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205import osimport stringimport signalfrom gmpy2 import *from Crypto.Util.number import *from hashlib import sha256, sha512, md5from random import randint, seed, choicefrom SECRET import FLAGclass KGC: def __init__(self, lam): self.lam = lam while 1: self.z = 2 * randint(1 &lt;&lt; 63, 1 &lt;&lt; 64) self.p = self.genPrime(self.z) self.q = self.genPrime(2) self.N = (self.z * self.p + 1) * (2 * self.q + 1) self.s1, self.s2 = randint(1, self.N), randint(1, self.N) if self.s1 % 2 == self.s2 % 2: self.s1 += 1 self.g = randint(1, self.N) check = pow(self.g, self.p * self.q, self.N) != 1 and pow(self.g, self.z * self.p, self.N) != 1 and pow(self.g, self.z * self.q, self.N) != 1 while not check: self.g = randint(1, self.N) check = pow(self.g, self.p * self.q, self.N) != 1 and pow(self.g, self.z * self.p, self.N) != 1 and pow(self.g, self.z * self.q, self.N) != 1 break self.g1, self.g2, self.g3 = (pow(self.g, self.p * self.s1, self.N), pow(self.g, self.p * self.s2, self.N), pow(self.g, self.p ** 2, self.N)) def genPrime(self, delta): prime = 1 while not isPrime(prime): prime = delta * getPrime(self.lam // 2 - delta.bit_length()) + 1 return (prime - 1) // delta def H1(self, m): return int(sha256(m.encode()).hexdigest(), 16) def H2(self, m): return int(sha512(m.encode()).hexdigest(), 16) def H3(self, m): return int(md5(m.encode()).hexdigest(), 16) def KeyGen(self, username): h1, h2 = self.H1(username), self.H2(username) y1 = invert(self.p, self.z * self.q) * h1 % (self.z * self.q) y2 = invert(self.p, self.z * self.q) * h2 % (self.z * self.q) d = invert(y1 * self.s1 + y2 * self.s2, self.z * self.q) e = pow(self.g1, h1, self.N) * pow(self.g2, h2, self.N) % self.N return (y1, y2, d, h1, h2, e) def enc(self, m, user): length_limit = 2**128 r = randint(1, self.N) F = pow(self.g3, r, self.N) c1 = (m % length_limit) ^ self.H3(str(F)) c2 = pow(user.e, r, self.N) return (c1, c2) def dec(self, c, user): c1, c2 = c F = pow(c2, user.d, self.N) m = long_to_bytes(self.H3(str(F)) ^ c1) return mclass USER: def __init__(self, id_, kgc): self.id_ = id_ self.y1, self.y2, self.d, self.h1, self.h2, self.e = kgc.KeyGen(id_) def print_info(self): print(f'e, d, h1, h2 = ({self.e}, {self.d}, {self.h1}, {self.h2})')def register(username, kgc): user = USER(username, kgc) return user def intercept(): while True: try: informant = 'WMCTF_IS_FUN_' + str(getRandomNBitInteger(512)) # randomize a big string USERLIST[informant] = register(informant, kgc) INFORMATION = randint(1 &lt;&lt; 127, 1 &lt;&lt; 128) return informant, INFORMATION except: passdef proof_of_work(): seed(os.urandom(8)) proof = ''.join([choice(string.ascii_letters + string.digits) for _ in range(20)]) digest = sha256(proof.encode()).hexdigest() print(\"sha256(XXXX+%s) == %s\" % (proof[4:], digest)) print('Give me XXXX: ', end = '') x = input().strip() if len(x) != 4 or sha256((x + proof[4:]).encode()).hexdigest() != digest: return False return Truedef BANNER(): print( ''' |--------------| | [P]arams | | [R]egister | | [E]ncrypt | | [D]ecrypt | | [I]ntercept | | [G]etflag | |--------------| ''')if __name__ == \"__main__\": if not proof_of_work(): exit() LAM = 512 LIMITED_USER_NUM = 6 kgc = KGC(LAM) USERLIST = {} informant, INFORMATION = intercept() signal.alarm(5) BANNER() while True: op = input('Input your choice please: ') if op == 'P': print(f'Here gives you some params about the KGC: {kgc.N}, ({kgc.g1}, {kgc.g2}, {kgc.g3})') elif op == 'R': if len(USERLIST) &gt;= LIMITED_USER_NUM: print('No more new registration allowed!') continue username = input('Input your name: ').strip() try: if username not in USERLIST: USERLIST[username] = register(username, kgc) print('Registration success, keep your account well!') USERLIST[username].print_info() else: print('This username has been taken!') except: print('Registration Not Allowed!') elif op == 'E': username = input('Input your name: ').strip() try: if username in USERLIST: message = input('Input your message in HEX: ').strip() cipher = kgc.enc(int(message, 16), USERLIST[username]) print(f'Here is the ciphertext: {cipher}') else: print('This user does not exist!') except: print('Bad Request!') elif op == 'D': username = input('Input your name: ').strip() prikey = input('Input your private key: ').strip() try: if username in USERLIST and USERLIST[username].d == prikey: c1, c2 = input('Input ciphers(c1, c2) in HEX: ').strip()[1:-1].split(', ')[0:2] c1, c2 = int(c1, 16), int(c2, 16) m = kgc.dec((c1, c2), USERLIST[username]) print(f'Here is the message: {m}') else: print('Bad Request!') except: print('Bad Request!') elif op == 'I': CIPHER = kgc.enc(INFORMATION, USERLIST[informant]) print(f'Here you intercepted a piece of message {CIPHER} sent by {informant}...') elif op == 'G': message = str(input('Input right messages in HEX and you\\'ll get your bonus: ')) try: message = int(message, 16) except: print('Illegal input!') continue if INFORMATION == message: print(f'Here is your flag: {FLAG}!') else: print('You really let me down..') exit() else: print('Have a nice day!') exit() 题目代码很长，参数很多，看到第一眼就有种看不下去想放弃的感觉，但还是凭着学习的本心硬着头一点点啃下去了。 这里先大致捋一下题目的逻辑。 首先有一个全局KGC用于产生用户密钥，其中KGC中包含以下参数： KGC公开参数。 然后提供了用户注册功能，根据用户的id，KGC会为其分配公私钥，产生的公私钥的参数如下： 其中参数用户保留可见。 接下来是用户加密消息功能，过程如下: 密文为。 同时提供解密功能，需要提供私钥，其对应解密为： 加解密的过程可以稍微手动推一下，是没有问题的~ 然后回到题目的意图，题目模拟拦截了一个随机用户发送消息的流量，已知的只有该用户的id和该随机消息的密文。我们需要还原出该消息来提供给系统获取flag。可以利用的条件包括不超过6次的用户注册所提供的相关信息（用户id不能有相同），以及任意次数的加密解密功能。 常规思路就是尝试去获取该用户的私钥了。我们从现有的已知条件和需求出发，已知不超过6组的，尝试获取指定的（用户id的哈希）对应的。 这看起来似乎是可行的，我们先对一些公式做一些变形： 这样一来，我们将未知参数用已知参数来表示。 由于是KGC的共用参数，那么对于任意两组和，我们有： 这里未知。但仔细观察该式特点，我们再使用两组和来构造以上关系，然后等式两边交换相乘即可同时消去和！也就是说我们可以拿到仅用已知参数来表示的，且模为0的式子！那么故技重施再算一次，然后求gcd，即可拿到模数。 后面就比较简单了，我们可以根据 得到和之间的线性关系（无需求出和的值），假设为 因此有： 因此对于指定，对任意我们有： 这样就求出了该用户的私钥！ 注意这里由于gcd和取模运算等原因，该可能不是准确值，因此提交到系统的解密功能中可能会出错。但我们手动进行解密仍然能计算出正确的消息明文。 该题至此已经解出。然而比赛时还有坑的一点是，由于用户id和消息是随机的，因此很多地方的求逆运算结果都是不存在逆元，因此想要使程序按正确路线跑完还是比较费劲的，得多跑几次（一度怀疑自己的推理逻辑对不对，还重新看了好几遍）。加之服务器产生KGC参数有时非常慢，当时我是做吐了—_—! 解出后和出题人交流过程中，发现该解法竟是非预期。预期解是打穿KGC???再蹲一波预期解好吧~ 解题脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121from pwn import *import reimport stringfrom hashlib import sha256,sha512,md5from itertools import product,combinations,permutationsfrom functools import reducefrom collections import Counterfrom gmpy2 import invertfrom Crypto.Util.number import *context.log_level = 'debug'sh=remote('1.13.154.182',30126)l64 = lambda :u64(sh.recvuntil(\"\\x7f\")[-6:].ljust(8,\"\\x00\"))l32 = lambda :u32(sh.recvuntil(\"\\xf7\")[-4:].ljust(4,\"\\x00\"))sla = lambda a,b :sh.sendlineafter(str(a),str(b))sa = lambda a,b :sh.sendafter(str(a),str(b))lg = lambda name,data : sh.success(name + \": 0x%x\" % data)se = lambda payload: sh.send(payload)rl = lambda : sh.recvline()rv = lambda n : sh.recv(n)sl = lambda payload: sh.sendline(payload)ru = lambda a :sh.recvuntil(str(a))rud = lambda a :sh.recvuntil(str(a),drop=True)def solve_pow(): s=rl().decode() suffix,val=re.findall('sha256\\(XXXX\\+(\\w{16})\\) == ([0-9a-f]{64})',s)[0] tab=string.digits + string.ascii_letters for item in product(tab,repeat=4): ans=''.join(item) if sha256((ans+suffix).encode()).hexdigest()==val: sla('XXXX: ',ans) returndef Param(): sla('choice please: ','P') ru('about the KGC: ') N=int(rud(', (')) g1=int(rud(', ')) g2=int(rud(', ')) g3=int(rud(')\\n')) return N,g1,g2,g3def Intercept(): sla('choice please: ','I') ru('of message ') cipher=rud(' sent by ') informant=rud('...\\n').decode() return eval(cipher),informantdef Register(name): sla('choice please: ','R') sla('Input your name: ',str(name)) if b'Not Allowed!' in rl(): name=bytes_to_long(name.encode()) new_name=long_to_bytes(name+1) return Register(new_name.decode()) info=rl()[16:-2].decode() e,d,h1,h2=list(map(int,info.split(', '))) return e,d,h1,h2,namedef Decrypt(name,d,c1,c2): sla('choice please: ','D') sla('Input your name: ',name) sla('private key: ',d) cip=f'({c1}, {c2})' if b'Bad' in rl(): return None sl(cip) ru('message: ') message=rl()[:-1].decode() return messagedef GetFlag(m): sla('choice please: ','G') sla('bonus: ',hex(m)[2:])def solve(): solve_pow() N,g1,g2,g3=Param() CIPHER,informant=Intercept() c1,c2=CIPHER H1=int(sha256(informant.encode()).hexdigest(), 16) H2=int(sha512(informant.encode()).hexdigest(), 16) e1,d1,h11,h21,name1=Register('zealot_aaa') e2,d2,h12,h22,name2=Register('zealot_bbb') e3,d3,h13,h23,name3=Register('zealot_ccc') e4,d4,h14,h24,name4=Register('zealot_ddd') e5,d5,h15,h25,name5=Register('zealot_eee') arr=[(e1, d1, h11, h21),(e2, d2, h12, h22),(e3, d3, h13, h23),(e4, d4, h14, h24),(e5, d5, h15, h25)] tmp=[] for a,b,c in permutations(arr,3): l=(a[1]*a[2]-b[1]*b[2])*(c[1]*c[3]-a[1]*a[3]) r=(b[1]*b[3]-a[1]*a[3])*(a[1]*a[2]-c[1]*c[2]) tmp.append(l-r) zq=reduce(GCD,tmp) #print(zq) #print(zq.bit_length()) #s1=k*s2 klist=[] for a,b in permutations(arr,2): try: t=((a[1]*a[3]-b[1]*b[3])*invert(b[1]*b[2]-a[1]*a[2],zq))%zq klist.append(t) except: continue klist=list(set(klist)) print(klist) if(len(klist)!=1): exit(0) D=d1*(h11*klist[0]+h21)*invert(H1*klist[0]+H2,zq)%zq F=pow(c2,D,N) HF=int(md5(str(F).encode()).hexdigest(), 16) m=c1^HF GetFlag(m)solve()sh.interactive()#WMCTF{cracking_such_a_toy_system_is_so_easy!}","link":"/202208/ebfe4390.html"},{"title":"corCTF2022 部分Crypto wp复现","text":"准备抽空把corCTF2022里几个低解Crypto题目复现学习一下，先能码多少是多少吧。 [corCTF 2022] threetreasures 题目源码： 123456789101112131415161718192021222324from sage.all import *from Crypto.Util.number import bytes_to_long, getPrimefrom random import getrandbitsfrom secret import flag, p, x, ydef random_pad(n, length): return (n &lt;&lt; (length - n.bit_length())) + getrandbits(length - n.bit_length())flag = bytes_to_long(flag)fbits = flag.bit_length()piece_bits = fbits // 3a, b, c = flag &gt;&gt; (2 * piece_bits), (flag &gt;&gt; piece_bits) % 2**piece_bits, flag % 2**piece_bitsprint(f'flag bits: {fbits}')assert p.bit_length() == 512q = getPrime(512)n = p * qct = pow(random_pad(c, 512), 65537, n)E = EllipticCurve(GF(p), [a, b])G = E(x, y)assert G * 3 == E(0, 1, 0)print(f\"n = {n}\")print(f\"ct = {ct}\")print(f\"G = {G}\") 题目中将375bits的flag分为125bits的a,b,c。其中c使用RSA进行加密，a,b用作ECC的构造参数，且RSA与ECC共用参数p。 题目给出了一个椭圆曲线上阶为3的点G，即：.稍加变形有：,因此有.根据倍乘公式, 即可得到, 这里a的高位是已知的（flag格式为‘corctf{’），可以直接用coppersmith攻击解出a。然后利用gcd可以得到模数p。接着根据可以得到b。最后由于因子p已经算出，解RSA即可还原出c。 解题脚本如下： 123456789101112131415161718192021222324252627from Crypto.Util.number import *flag_bits = 375n = 97915144495462666300795364589570761584322186881492143950078938328867290046424857019504657598883431857075772605985768551863478086544857915637724181292135280539943713583281151707224031808445390796342632369109562433275679473233398168787639940620683354458292117457239552762694657810883738834935391913698852811737ct = 20363336204536918055183609604474634074539942561101208682977506918349108499764147141944713060658857301108876346227077713201766486360148051069618774935469969057808945271860025712869868421279488925632657486125211168314387620225601572070169746014988350688548088791906161773656057212229972967244998930356157725393Gx,Gy = (3115938227771961657567351113281194074601897467086373590156577019504528350118731801249444974253028485083440228959842232653488953448859690520619223338133881 , 2665631524518629436093690344927156713668794128141943350227439039472817541262750706395352700109556004195261826476428128993836186741129487842876154876730189)e=65537pref=bytes_to_long(b'corctf{')ahbits=pref.bit_length()kbits=125-ahbitsprint(kbits)ah=pref&lt;&lt;kbitsR.&lt;al&gt;=PolynomialRing(Zmod(n))f=(3*Gx^2+ah+al)^2-12*Gx*Gy^2root=int(f.small_roots(X=2^kbits,beta=0.4)[0])a=ah+rootG0=(3*Gx^2+a)^2-12*Gx*Gy^2p=gcd(G0,n)assert isPrime(p)b=int((Gy^2-Gx^3-a*Gx)%p)q=n//pd=inverse(e,(p-1)*(q-1))c=int(pow(ct,d,n)&gt;&gt;(512-125))flag=(a&lt;&lt;250)+(b&lt;&lt;125)+cprint(long_to_bytes(flag))#b'corctf{you_have_conquered_the_order_of_three!!}' [corCTF 2022] corrupted-curves &amp; corrupted-curves+ 一道ecc+lattice的题目，感觉质量蛮好的，看了两天终于差不多了，感觉格这一块儿还是不熟，重新温习相关知识花了好长时间。 corrupted-curves+题目源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#!/usr/local/bin/pythonfrom secrets import randbitsfrom Crypto.Util.number import getPrimefrom random import randrangedef square_root(a, p): if legendre_symbol(a, p) != 1: return 0 elif a == 0: return 0 elif p == 2: return 0 elif p % 4 == 3: return pow(a, (p + 1) // 4, p) s = p - 1 e = 0 while s % 2 == 0: s //= 2 e += 1 n = 2 while legendre_symbol(n, p) != -1: n += 1 x = pow(a, (s + 1) // 2, p) b = pow(a, s, p) g = pow(n, s, p) r = e while True: t = b m = 0 for m in range(r): if t == 1: break t = pow(t, 2, p) if m == 0: return x gs = pow(g, 2 ** (r - m - 1), p) g = (gs * gs) % p x = (x * gs) % p b = (b * g) % p r = mdef legendre_symbol(a, p): ls = pow(a, (p - 1) // 2, p) return -1 if ls == p - 1 else lsclass EllipticCurve: def __init__(self, p, a, b): self.a = a self.b = b self.p = p if not self.check_curve(): raise Exception(\"Not an elliptic curve!\") def check_curve(self): discrim = -16 * (4*pow(self.a, 3) + 27*pow(self.b, 2)) if discrim % self.p: return 1 return 0 def lift_x(self, px): y2 = (pow(px, 3) + self.a*px + self.b) % self.p py = square_root(y2, self.p) if py == 0: raise Exception(\"No point on elliptic curve.\") return pywith open(\"flag.txt\", \"rb\") as f: flag = f.read() flag = int.from_bytes(flag, 'big')print(\"Generating parameters...\")while True: p = getPrime(512) a, b = randbits(384), randbits(384) try: E = EllipticCurve(p, a, b) fy = E.lift_x(flag) print(f\"p = {p}\") print(f\"flag y = {fy}\") break except: continuechecked = set()count = 0while count &lt; 2022: x = randrange(2, p) if int(x) in checked or x &lt; 2**384 or abs(x - p) &lt; 2**384: print(\"&gt;:(\") continue try: e = randbits(48) print(f\"e = {e}\") E = EllipticCurve(p, a^e, b^e) py = E.lift_x(x) checked.add(x) print(f\"x = {x}\") print(f\"y = {py}\") count += 1 except: print(\":(\") more = input(\"more&gt; \") if more.strip() == \"no\": breakprint(\"bye!\") corrupted-curves的区别仅在于x可选择输入，e为64位。两个题版本之间没有太多改变，因此只记录corrupted-curves+的解法。 题目定义了椭圆曲线的实现，已知p和flag_y，并且点在椭圆曲线上。然后给了一个oracle，可以得到椭圆曲线上的随机点，e是给出的48位随机值。简单分析可以知道，题目的首要目标是利用oracle来求出a和b。 首先得到oracle生成的两个点： 由于和e的异或运算只影响a,b的低48位，为了简便表示，记： 且令： 则有： 两式相减消去b，并将a分解为高位(336bits)和低位(48bits)： 于是我们可以根据等式： 构造格矩阵： 令 可以证明向量是在格M上的，因为。并且，向量r的长度非常短，趋近于1。因此，我们对格矩阵M进行LLL规约求解SVP问题可以得到短向量r，从而得到a的高位。 除此之外，我们还可以从向量r中得到，由于（异或运算只影响低位），我们可以求出，从而得到完整的a的值。 接着很容易得到b的值： 拿到a,b之后利用椭圆曲线方程求flag_y对应的根即可。 解题脚本solve.sage如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *from Crypto.Util.number import *sh = remote('be.ax',31132)context.log_level='debug'l64 = lambda :u64(sh.recvuntil(\"\\x7f\")[-6:].ljust(8,\"\\x00\"))l32 = lambda :u32(sh.recvuntil(\"\\xf7\")[-4:].ljust(4,\"\\x00\"))sla = lambda a,b :sh.sendlineafter(str(a),str(b))sa = lambda a,b :sh.sendafter(str(a),str(b))lg = lambda name,data : sh.success(name + \": 0x%x\" % data)se = lambda payload: sh.send(payload)rl = lambda : sh.recvline()rv = lambda n : sh.recv(n)sl = lambda payload: sh.sendline(payload)ru = lambda a :sh.recvuntil(str(a))rud = lambda a :sh.recvuntil(str(a),drop=True)def getpoints(): points=[] cnt=0 while cnt&lt;2: line=rl().decode() if '&gt;:(' not in line: print(line) e=int(line.split('e = ')[1]) line=rl().decode() if ':(' not in line: x=int(line.split('x = ')[1]) ru('y = ') y=int(rl()) points.append((e,x,y)) cnt+=1 sla('more&gt; ','yes') sla('more&gt; ','no') sh.close() return points ru('p = ')p=int(rl())ru('flag y = ')flagy=int(rl())points=getpoints()e1,x1,y1=points[0]e2,x2,y2=points[1]m1=(y1^2-x1^3)%pm2=(y2^2-x2^3)%pm=Matrix(QQ,6,6)m.set_column(0,[p,2^48*(x1-x2)%p,-x1,x2,1,(m2-m1)%p])m[1,1]=2^-336for i in range(2,5): m[i,i]=2^-48m[5,5]=1res=m.LLL()#print(res)for row in res: if row[0]==0 and row[-1]==1: au=Integer(row[1]*2^384) al=Integer(-row[2]*2^48)^^e1 a=au+al b=((m1-(a^^e1)*x1)%p)^^e1 R.&lt;X&gt;=PolynomialRing(Zmod(p)) f=X^3+a*X+b-flagy^2 roots=f.roots() for root in roots: print(long_to_bytes(int(root[0]))) corrupted-curves解题脚本类似，稍微修改一下交互函数和位数即可。 [corCTF 2022] rlfsr 题目源码： 1234567891011121314151617181920212223242526272829303132from secrets import randbitsfrom random import shufflefrom hashlib import sha256from Crypto.Cipher import AESfrom Crypto.Util.Padding import padclass LFSR: def __init__(self, key, taps): self.key = key self.taps = taps self.state = list(map(int, list(\"{:0128b}\".format(key)))) def _clock(self): ob = self.state[0] self.state = self.state[1:] + [sum([self.state[t] for t in self.taps]) % 2] return obkey = randbits(128)l = LFSR(key, [1, 2, 7, 3, 12, 73])out = []for i in range(118): bits = [l._clock() for _ in range(128)] shuffle(bits) out += bitsprint(hex(sum([bit*2**i for i, bit in enumerate(out)])))flag = open(\"flag.txt\", \"rb\").read()iv = randbits(128).to_bytes(16, 'big')aeskey = sha256(key.to_bytes(16, 'big')).digest()[:32]print((iv + AES.new(aeskey, AES.MODE_CBC, iv=iv).encrypt(pad(flag, 16))).hex()) 一个经典的lfsr，只不过每128位加了一个shuffle。大致思路是考虑用sum来消除shuffle的影响（因为shuffle前后的求和是不变的），此外题目提供了118组128bits输出，因此可以在上构建118种与key相关的线性关系然后用groebner_basis求解，剩余10bits可以直接爆破。 直接上解题脚本solve.sage： 123456789101112131415161718192021222324252627282930313233343536373839404142434445from Crypto.Util.number import *from Crypto.Cipher import AESfrom hashlib import sha256from tqdm import tqdmclass LFSR: def __init__(self, key, taps): self.key = key self.taps = taps self.state = key def _clock(self): ob = self.state[0] self.state = self.state[1:] + [sum([self.state[t] for t in self.taps]) ] return oblines=open('output.txt','r').readlines()out=list(map(int,bin(int(lines[0],16))[2:].zfill(118*128)))[::-1]out_parts=[ out[i:i+128] for i in range(0,len(out),128)]ct=bytes.fromhex(lines[1])iv = ct[:16]c = ct[16:]R=PolynomialRing(GF(2),['x%d'%i for i in range(128)])key=list(R.gens())l = LFSR(key, [1, 2, 7, 3, 12, 73])I=[]for i in range(118): bits = [l._clock() for _ in range(128)] I.append(sum(bits)-sum(out_parts[i])%2)for i in tqdm(range(2^11)): guess=list(map(int,bin(int(i))[2:].zfill(11))) guessI=[key[i]-guess[i] for i in range(11)] res=Ideal(I+guessI).groebner_basis() if len(res)!=1: k=int(''.join([ str(res[i].constant_coefficient()) for i in range(len(res))]),2) aeskey = sha256(k.to_bytes(16, 'big')).digest()[:32] cipher=AES.new(aeskey,AES.MODE_CBC,iv) m=cipher.decrypt(c) if b'corctf{' in m: print(m) exit(0)#corctf{m4yb3_w3_sh0uld_ju5t_cut_hum4n5_0ut_0f_th1s_c0mpl3t3ly_1f_th3y_d3c1d3_t0_f4k3_shuffl3_0r_s0m3th1ng} 这里爆破时是而不是，用会爆不出来，很奇怪。我想可能是因为要排除掉第一个128bits块的影响。","link":"/202208/77a08f09.html"},{"title":"博客开张小记","text":"一直以来都想做个博客来记录一下学习历程，今天捣鼓了一晚上终于弄好了，还挑了一个自己比较喜欢的主题。以后会不定期更新CTF的一些题目（主要是密码学），记录自己从菜鸟成长进阶经历。当然其它方面的有价值的东西，或者是踩坑之类的经历也可能会做一下记录。加油吧，少年~","link":"/202208/8f715123.html"},{"title":"第五届美团CTF初赛&amp;决赛Crypto wp","text":"被师傅们带进决赛了，tql呜呜呜。 [初赛]strange_rsa1 题目源码： 123456789101112131415161718from Crypto.Util.number import *from sage.all import RealFieldfrom secret import flag1Bits = 512p = getPrime(Bits)q = getPrime(Bits)n = p * qgift = RealField(prec=Bits*2)(p) / RealField(prec=Bits*2)(q)e = 0x10001m = bytes_to_long(flag1)c = pow(m, e, n)output = open('output.txt', 'w')output.write('n = ' + str(n) + '\\n')output.write('c = ' + str(c) + '\\n')output.write('gift = ' + str(gift) + '\\n') 直接在给定的实数域上求根，然后转整数得到 q，解 RSA 即可。 解题脚本： 1234567891011121314151617from Crypto.Util.number import *e = 0x10001n = 108525167048069618588175976867846563247592681279699764935868571805537995466244621039138584734968186962015154069834228913223982840558626369903697856981515674800664445719963249384904839446749699482532818680540192673814671582032905573381188420997231842144989027400106624744146739238687818312012920530048166672413c = 23970397560482326418544500895982564794681055333385186829686707802322923345863102521635786012870368948010933275558746273559080917607938457905967618777124428711098087525967347923209347190956512520350806766416108324895660243364661936801627882577951784569589707943966009295758316967368650512558923594173887431924gift = 0.9878713210057139023298389025767652308503013961919282440169053652488565206963320721234736480911437918373201299590078678742136736290349578719187645145615363088975706222696090029443619975380433122746296316430693294386663490221891787292112964989501856435389725149610724585156154688515007983846599924478524442938F=RealField(prec=512*2)R.&lt;x&gt;=PolynomialRing(F)f=x*x*gift-nr=f.roots()[0][0]q=int(abs(r))p=n//qd=inverse(e,(p-1)*(q-1))m=pow(c,d,n)print(long_to_bytes(m))#b'flag{a5537b232c1ab750e0db61ec352504a301b7b212}' [初赛]strange_rsa2 题目源码： 123456789101112131415161718192021222324252627282930from Crypto.Util.number import *from secret import flag1, flag2def generate_poly(modulus, num, root): poly = [] res = 0 for i in range(1, num+1): poly.append(getRandomRange(1, modulus-1)) res = (res + poly[-1] * pow(root, i, modulus)) % modulus return [modulus-res] + polyBits = 512p = getPrime(Bits)q = getPrime(Bits)n = p * qa = getRandomRange(1, p-1)k = bytes_to_long(flag1)gift = [generate_poly(p, Bits, a), generate_poly(p, Bits, k * a)]e = 0x10001m = bytes_to_long(flag2)c = pow(m, e, n)output = open('output.txt', 'w')output.write('n = ' + str(n) + '\\n')output.write('c = ' + str(c) + '\\n')output.write('gift = ' + str(gift) + '\\n') 注意这题用到了上题的 flag（本题的坑点）。 给出了两个随机多项式，我的想法是构造二元多项式，用 grobner 基求出 a。由于模数 p 未知，先用 n 替代。然而解完惊奇地发现顺带把 p 直接规约出来了，属于是意外收获了。后面解RSA 就 OK 了。 解题脚本： 123456789101112131415161718192021222324252627282930from Crypto.Util.number import *def my_poly(coe,x): res=0 for i in range(1,513): res+=coe[i-1]*(x^i) return rese = 0x10001flag1 = b'flag{a5537b232c1ab750e0db61ec352504a301b7b212}'k = bytes_to_long(flag1)exec(open('output.txt','r').read())R.&lt;a,t&gt;=PolynomialRing(Zmod(n))s1=gift[0][0]coe1=gift[0][1:]s2=gift[1][0]coe2=gift[1][1:]f1=my_poly(coe1,a)+s1f2=my_poly(coe2,t)+s2res=Ideal([f1,f2,t-k*a]).groebner_basis()print(res)res=[ x.constant_coefficient() for x in res]a,t,p=list(map(int,res))print(a,t,p)q=n//pd=inverse(e,(p-1)*(q-1))m=pow(c,d,n)print(long_to_bytes(int(m)))#b'flag{e6d7511d75bd537e1bd0cd08abea415f5f27d6cf}' [决赛]strange_lwe 题目源码： 12345678910111213141516171819202122232425262728293031323334353637383940from Crypto.Util.number import *from hashlib import sha1from secret import my_secret_bits, flagfrom sage.all import *from sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSamplerdef matrix_to_list(M): count = M.nrows() dimension = M.ncols() Matrix_list = M.list() M = [] for i in range(count): M.append(Matrix_list[i * dimension:(i+1) * dimension]) if len(M) == 1: return M[0] return Mq = 401m = 64n = 16a = 0.025A = random_matrix(GF(q), m, n)t = DiscreteGaussianDistributionIntegerSampler(a*q)s = random_matrix(GF(q), n, 1)num = 48assert flag == 'flag{' + sha1(str(my_secret_bits).encode()).hexdigest() + '}'cipher = []for j in range(num): if my_secret_bits[j] == 0: cipher.append([random_vector(GF(q), m).list() for _ in range(num*8)]) else: cipher.append([(A * s + Matrix([t() for _ in range(m)]).transpose()).list() for _ in range(num*8)])A = matrix_to_list(A)data = str([[int(A[i][j]//8) for j in range(len(A[0]))] for i in range(len(A))]) + '\\n'data += str(cipher)open('data.txt', 'w').write(data) LWE问题，形如，其中给定矩阵A和向量b，e是一个很小的误差向量，目标是求出s向量。该问题可以转化为格密码中的CVP求解问题，即求出格中的一个向量，使其距离目标向量b最近。通常可以使用babai's nearest plane algorithm算法求解。 直接输出误差向量来判断会发现很多bits对不上，搞了半天不太懂什么原因。但还好能算出s向量，因此绕了个弯通过s再来反求误差。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSamplerfrom sage.modules.free_module_integer import IntegerLatticeimport numpy as npfrom Crypto.Util.number import *from hashlib import sha1# Babai's Nearest Plane algorithmdef Babai_closest_vector(M, G, target): small = target for _ in range(5): for i in reversed(range(M.nrows())): c = ((small * G[i]) / (G[i] * G[i])).round() small -= M[i] * c return target - smallq = 401m = 64n = 16a = 0.025num = 48data=open('data.txt','r').readlines()A=Matrix(ZZ,eval(data[0].strip()))cipher=eval(data[1].strip())print(len(cipher))'''#find the same s vector that output bit '1'res=''for k in range(num): rt=cipher[k][0] Lattice = matrix(ZZ, m + n, m) for i in range(m): for j in range(n): Lattice[m + j, i] = A[i][j] Lattice[i, i] = q lattice = IntegerLattice(Lattice, lll_reduce=True) print(\"LLL done\") gram = lattice.reduced_basis.gram_schmidt()[0] target = vector(ZZ,rt) cv = Babai_closest_vector(lattice.reduced_basis, gram, target) #print(\"Closest Vector: {}\".format(cv)) error=cv-target print(\"Error: {}\".format(error)) if any([abs(e)&gt;40 for e in error]): res+='0' else: res+='1' print(res) A = matrix(Zmod(q), A) try: s = A.solve_right(cv) print('s: {}'.format(s)) except: print(\"no solution\") continueprint(res)'''s=(195, 202, 322, 287, 230, 311, 396, 58, 242, 191, 117, 41, 248, 264, 139, 291)s=vector(GF(q),s)A=Matrix(GF(q),A)print(A*s)res=''for k in range(num): tmp=[] for l in range(num*8): c=vector(ZZ,cipher[k][l]) As=vector(GF(q),A*s) t=c-As t=[tt if tt&lt;(q//2) else q-tt for tt in t] tmp.extend(t) if all([ tt&lt;40 for tt in t]): res+='1' else: res+='0'print(res)#res='000000110110001010100111101100001101011110011110'my_secret_bits=list(map(int,res))flag = 'flag{' + sha1(str(my_secret_bits).encode()).hexdigest() + '}'print(flag)#flag{7e0fefd15c630d4b41db2ac9e18d48d691b3d419}","link":"/202209/de508044.html"}],"tags":[{"name":"ecc","slug":"ecc","link":"/tags/ecc/"},{"name":"Modulus Fault Attack","slug":"Modulus-Fault-Attack","link":"/tags/Modulus-Fault-Attack/"},{"name":"continued fraction","slug":"continued-fraction","link":"/tags/continued-fraction/"},{"name":"RS encode","slug":"RS-encode","link":"/tags/RS-encode/"},{"name":"RSA Variant","slug":"RSA-Variant","link":"/tags/RSA-Variant/"},{"name":"mt19937","slug":"mt19937","link":"/tags/mt19937/"},{"name":"lattice","slug":"lattice","link":"/tags/lattice/"},{"name":"dlp","slug":"dlp","link":"/tags/dlp/"},{"name":"coppersmith","slug":"coppersmith","link":"/tags/coppersmith/"},{"name":"RSA variant","slug":"RSA-variant","link":"/tags/RSA-variant/"},{"name":"NTRU","slug":"NTRU","link":"/tags/NTRU/"},{"name":"HE","slug":"HE","link":"/tags/HE/"},{"name":"secure aggregation","slug":"secure-aggregation","link":"/tags/secure-aggregation/"},{"name":"blockchain intro","slug":"blockchain-intro","link":"/tags/blockchain-intro/"},{"name":"self destruct","slug":"self-destruct","link":"/tags/self-destruct/"},{"name":"Reentrancy Attack","slug":"Reentrancy-Attack","link":"/tags/Reentrancy-Attack/"},{"name":"backdoor","slug":"backdoor","link":"/tags/backdoor/"},{"name":"parity oracle","slug":"parity-oracle","link":"/tags/parity-oracle/"},{"name":"FHE","slug":"FHE","link":"/tags/FHE/"},{"name":"lfsr","slug":"lfsr","link":"/tags/lfsr/"},{"name":"小记","slug":"小记","link":"/tags/%E5%B0%8F%E8%AE%B0/"},{"name":"LWE","slug":"LWE","link":"/tags/LWE/"}],"categories":[{"name":"Crypto","slug":"Crypto","link":"/categories/Crypto/"},{"name":"NKCTF","slug":"Crypto/NKCTF","link":"/categories/Crypto/NKCTF/"},{"name":"2022巅峰极客","slug":"Crypto/2022巅峰极客","link":"/categories/Crypto/2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/"},{"name":"ByteCTF","slug":"Crypto/ByteCTF","link":"/categories/Crypto/ByteCTF/"},{"name":"NepCTF出题","slug":"Crypto/NepCTF出题","link":"/categories/Crypto/NepCTF%E5%87%BA%E9%A2%98/"},{"name":"2022羊城杯","slug":"Crypto/2022羊城杯","link":"/categories/Crypto/2022%E7%BE%8A%E5%9F%8E%E6%9D%AF/"},{"name":"Blockchain","slug":"Blockchain","link":"/categories/Blockchain/"},{"name":"N1CTF","slug":"Crypto/N1CTF","link":"/categories/Crypto/N1CTF/"},{"name":"XCTF","slug":"Crypto/XCTF","link":"/categories/Crypto/XCTF/"},{"name":"ctfshow","slug":"Crypto/ctfshow","link":"/categories/Crypto/ctfshow/"},{"name":"WMCTF2022","slug":"Crypto/WMCTF2022","link":"/categories/Crypto/WMCTF2022/"},{"name":"corCTF2022","slug":"Crypto/corCTF2022","link":"/categories/Crypto/corCTF2022/"},{"name":"MTCTF","slug":"Crypto/MTCTF","link":"/categories/Crypto/MTCTF/"},{"name":"NewStarCTF","slug":"Blockchain/NewStarCTF","link":"/categories/Blockchain/NewStarCTF/"}],"pages":[]}